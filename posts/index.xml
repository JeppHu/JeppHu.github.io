<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jepp Hu</title>
    <link>https://jepphu.github.io/posts/</link>
    <description>Recent content in Posts on Jepp Hu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Apr 2019 10:42:33 +0800</lastBuildDate>
    
	<atom:link href="https://jepphu.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1. 熟悉 Objective-C 的根源</title>
      <link>https://jepphu.github.io/2019/1.-%E7%86%9F%E6%82%89-objective-c-%E7%9A%84%E6%A0%B9%E6%BA%90/</link>
      <pubDate>Tue, 30 Apr 2019 10:42:33 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/1.-%E7%86%9F%E6%82%89-objective-c-%E7%9A%84%E6%A0%B9%E6%BA%90/</guid>
      <description> Objective-C 是 C 的超集，在 C 的基础上增加了面向对象的功能。 相比使用结构体，在使用对象的时候产生的开销可能会影响性能，例如分配和释放堆内存。 当不需要保存对象类型的时候，尽量使用诸如CGRect之类的结构体。
 Objective-C 使用具有动态绑定的消息传递结构，而不是函数调用：
  // Messaging Object *obj = [Object new]; [obj performWith:parameter1 and:parameter2];  Object *obj = new Object; obj-&amp;gt;perform(parameter1, parameter2);  关键的不同在于：消息传递结构中，由 Runtime 决定哪些代码被执行，编译器不关心接收消息的对象的类型，而是通过一个动态绑定的过程，在运行时去查找对象的类型。而函数调用中则由编译器来决定哪些代码被执行。
 理解 C 的核心概念将有助于您编写有效的 Objective-C。 特别是需要了解内存模型和指针。  </description>
    </item>
    
    <item>
      <title>2. 在头文件中尽可能少的引入其他头文件</title>
      <link>https://jepphu.github.io/2019/2.-%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B0%91%E7%9A%84%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%A4%B4%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 30 Apr 2019 10:42:33 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/2.-%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B0%91%E7%9A%84%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%A4%B4%E6%96%87%E4%BB%B6/</guid>
      <description> 如非必要，不要头文件中引入头文件，而用 @class Obj 来告诉编译器这个是一个类，在实现文件中再引入头文件。 这样可以加快编译速度，降低类之间的耦合，并减少可能循环引用的问题。
 有时候需要声明一个类遵循一项协议。这种情况下首先尽可能将“遵循协议”的代码写到类的扩展中去，从而避免在头文件中引用头文件，如果不行，那么将协议声明的代码单独放到一个头文件中，再去头文件中引用这个头文件，避免引入了其他类的声明。
  </description>
    </item>
    
    <item>
      <title>3. 多用字面语法，少用等价的其他语法</title>
      <link>https://jepphu.github.io/2019/3.-%E5%A4%9A%E7%94%A8%E5%AD%97%E9%9D%A2%E8%AF%AD%E6%B3%95%E5%B0%91%E7%94%A8%E7%AD%89%E4%BB%B7%E7%9A%84%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 30 Apr 2019 10:42:33 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/3.-%E5%A4%9A%E7%94%A8%E5%AD%97%E9%9D%A2%E8%AF%AD%E6%B3%95%E5%B0%91%E7%94%A8%E7%AD%89%E4%BB%B7%E7%9A%84%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/</guid>
      <description> 使用字面语法去创建 string，numbers，arrays 和 dictionaries，比起使用常规的对象方法相比要更简明  NSString *someStr = @&amp;quot;Objective-C&amp;quot;; NSString *someStr = [NSString stringWithFormat:@&amp;quot;%@&amp;quot;,@&amp;quot;Objective-C&amp;quot;]; NSNumber *someNum = @6; NSNumber *someNum = [NSNumber numberWithInt:6]; NSArray *animals = @[@&amp;quot;cat&amp;quot;,@&amp;quot;dog&amp;quot;,@&amp;quot;mouse&amp;quot;]; NSArray *animals = [NSArray arrayWithObjects:@&amp;quot;cat&amp;quot;,@&amp;quot;dog&amp;quot;,@&amp;quot;mouse&amp;quot;, nil]; NSDictionary *personData = @{@&amp;quot;firstName&amp;quot; : @&amp;quot;Matt&amp;quot;, @&amp;quot;lastName&amp;quot; : @&amp;quot;Galloway&amp;quot;, @&amp;quot;age&amp;quot; : [NSNumber numberWithInt:28]}; NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:@&amp;quot;Matt&amp;quot;, @&amp;quot;firstName&amp;quot;, @&amp;quot;Galloway&amp;quot;, @&amp;quot;lastName&amp;quot;, [NSNumber numberWithInt:28], @&amp;quot;age&amp;quot;, nil];   使用取下标操作来访问/修改数组下标对应的元素或者字典中健所对应的值  NSString *str = animals[1]; NSString *str = [animals objectAtIndex:1]; NSString *lastName = personData[@&amp;quot;personData&amp;quot;]; NSString *lastName = [personData objectForKey:@&amp;quot;lastName&amp;quot;];   一定要确保插入数组和字典中的对象没有 nil，否则会抛出异常  </description>
    </item>
    
    <item>
      <title>4. 多用类型常量，少用预处理指令 #define</title>
      <link>https://jepphu.github.io/2019/4.-%E5%A4%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%B0%91%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Tue, 30 Apr 2019 10:42:33 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/4.-%E5%A4%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%B0%91%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</guid>
      <description>宏定义常量属于预处理指令定义常量，会增加编译时间。对于常量的定义，使用类型常量定义，可减少编译时间，编译时类型报错也会提示，单独放在工程项目的某一个常量文件中更具可读性。
 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只会在编译前执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致；
 在实现文件中使用 static const 来定义“只在编译单元内可见的常量”（translation-unit-specific constant）。一个 .m 文件就是一个编译单元。由于此常量不在全局符号表中，所以无需为其名称加前缀。
  //.m static const NSTiemInterval AnimationDuration = 0.3;   在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区分，通常用与之相关的类名做前缀。  //.h extern NSString *const SomeString; extern const NSTiemInterval AnimationDuration; //.m NSString *const SomeString = @&amp;quot;Debug&amp;quot;; const NSTiemInterval AnimationDuration = 0.3;  </description>
    </item>
    
    <item>
      <title>5. 用枚举表示状态、选项、状态码</title>
      <link>https://jepphu.github.io/2019/5.-%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%A1%A8%E7%A4%BA%E7%8A%B6%E6%80%81%E9%80%89%E9%A1%B9%E7%8A%B6%E6%80%81%E7%A0%81/</link>
      <pubDate>Tue, 30 Apr 2019 10:42:33 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/5.-%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%A1%A8%E7%A4%BA%E7%8A%B6%E6%80%81%E9%80%89%E9%A1%B9%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
      <description>用枚举来表示状态机的状态、传递给方法的选项以及错误状态码等值，给这些值起个易懂的名字  typedef NS_ENUM(NSUInteger, EOCConnectionState) { EOCConnectionStateDisConnected = 1, EOCConnectionStateConnecting, EOCConnectionStateConnected, };   如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项定义为 2 的幂，以便通过按位或操作将其组合起来  typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) { UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &amp;lt;&amp;lt; 0, UIViewAutoresizingFlexibleWidth = 1 &amp;lt;&amp;lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &amp;lt;&amp;lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &amp;lt;&amp;lt; 3, UIViewAutoresizingFlexibleHeight = 1 &amp;lt;&amp;lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &amp;lt;&amp;lt; 5 };   用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。
 如果需要以按位或操作来组合的枚举都应该使用 NS_OPTIONS 宏，若枚举不需要互相组合，可以使用NS_ENUM 来定义，NS_ENUM 和 NS_OPTIONS 本质是一样的，仅仅从字面上来区分其用途，采用不同的宏来从代码角度来区分，而 enum 是 C 语言的枚举，OC 也同样适用</description>
    </item>
    
    <item>
      <title>NSJSONSerialization</title>
      <link>https://jepphu.github.io/2019/nsjsonserialization/</link>
      <pubDate>Fri, 15 Mar 2019 17:19:34 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsjsonserialization/</guid>
      <description> JSON 序列化 // 输出的 json 字符串就是一整行 NSJSONWritingSortedKeys // 是将生成的 json 数据格式化输出，这样可读性高，不设置则输出的 json 字符串就是一整行 NSJSONWritingPrettyPrinted  + (NSString *)jsonStringEncodedWithDic:(NSDictionary *)dic { if ([NSJSONSerialization isValidJSONObject:dic]) { NSError *error; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:0 error:&amp;amp;error]; NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; return json; } return nil; } + (NSString *)jsonPrettyStringEncodedWithDic:(NSDictionary *)dic { if ([NSJSONSerialization isValidJSONObject:dic]) { NSError *error; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;amp;error]; NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; return json; } return nil; }  JSON 反序列化 // 返回的对象是不可变的，NSDictionary 或 NSArray kNilOptions // 返回可变容器，NSMutableDictionary 或 NSMutableArray，返回的是数组字典嵌套的情况，每一层都是可变的 NSJSONReadingMutableContainers // 返回的 JSON 对象中字符串的值类型为 NSMutableString NSJSONReadingMutableLeaves // 允许JSON字符串最外层既不是 NSArray 也不是 NSDictionary，但必须是有效的JSON Fragment NSJSONReadingAllowFragments  + (id)jsonValueDecodedWithStr:(NSString *)str { NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding]; NSError *error; id value = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;amp;error]; if (error) { NSLog(@&amp;quot;%s error:%@&amp;quot;, __func__, error); } return value; }  </description>
    </item>
    
    <item>
      <title>NSString 语音阅读</title>
      <link>https://jepphu.github.io/2019/nsstring%E8%AF%AD%E9%9F%B3%E9%98%85%E8%AF%BB/</link>
      <pubDate>Fri, 15 Mar 2019 17:15:22 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsstring%E8%AF%AD%E9%9F%B3%E9%98%85%E8%AF%BB/</guid>
      <description>#import &amp;lt;AVFoundation/AVFoundation.h&amp;gt;  AVSpeechSynthesizer *synthesize = [[AVSpeechSynthesizer alloc]init]; AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc]initWithString:self.textView.text]; [synthesize speakUtterance:utterance];  </description>
    </item>
    
    <item>
      <title>NSString 复制到剪切板</title>
      <link>https://jepphu.github.io/2019/nsstring%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</link>
      <pubDate>Fri, 15 Mar 2019 17:11:42 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsstring%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</guid>
      <description>UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; pasteboard.string = self.textView.text;  </description>
    </item>
    
    <item>
      <title>NSString 与 UTF-8</title>
      <link>https://jepphu.github.io/2019/nsstring%E4%B8%8Eutf-8/</link>
      <pubDate>Fri, 15 Mar 2019 17:02:35 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsstring%E4%B8%8Eutf-8/</guid>
      <description> NSString 转 UFT-8 编码 NSString *text = @&amp;quot;你好, 世界&amp;quot;; NSCharacterSet *charSet = [[NSCharacterSet characterSetWithCharactersInString:text] invertedSet]; text = [text stringByAddingPercentEncodingWithAllowedCharacters:charSet];  UFT-8 转 NSString 解码 NSString *text = [text stringByRemovingPercentEncoding];  </description>
    </item>
    
    <item>
      <title>不使用 storyBoard</title>
      <link>https://jepphu.github.io/2019/%E4%B8%8D%E4%BD%BF%E7%94%A8storyboard/</link>
      <pubDate>Fri, 15 Mar 2019 15:56:28 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/%E4%B8%8D%E4%BD%BF%E7%94%A8storyboard/</guid>
      <description>纯代码的方式开始搭建界面 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *redView = [[UIViewController alloc] init]; redView.view.backgroundColor = [UIColor redColor]; //1. 直接以 UIViewController 作为 window 的根控制器 // self.window.rootViewController = redView; // [self.window makeKeyAndVisible]; //2. 以 UINavigationController 作为 window 的根控制器(44px) // UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:redView]; // nav.view.backgroundColor = [UIColor grayColor]; // self.window.rootViewController = nav; // [self.window makeKeyAndVisible]; //3. 以 UITabBarController 作为 window 的根控制器 UITabBarController *tabBarController = [[UITabBarController alloc] init]; UIViewController *v1 = [[UIViewController alloc] init]; v1.</description>
    </item>
    
    <item>
      <title>UIGestureRecognizer</title>
      <link>https://jepphu.github.io/2019/uigesturerecognizer/</link>
      <pubDate>Fri, 15 Mar 2019 15:45:29 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/uigesturerecognizer/</guid>
      <description>点击 // 创建点击手势对象 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)]; // 几个手指 tap.numberOfTouchesRequired = 2; // 点击几次 tap.numberOfTapsRequired = 2; // 给 View 添加一个手势 [self.imageView addGestureRecognizer:tap];  长按 UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)]; // 长按时间 longPress.minimumPressDuration = 0.5; // 在长按时移动允许的误差范围, 超过范围 误差失效 longPress.allowableMovement = 50; [self.imageView addGestureRecognizer:longPress];  - (void)longPress:(UILongPressGestureRecognizer *)sender { // 默认长按移动时会一直执行, 放开时也会执行, 加个判断, 只执行一次 if (sender.state == UIGestureRecognizerStateBegan) { NSLog(@&amp;quot;%s&amp;quot;, __FUNCTION__); } }  清扫 UISwipeGestureRecognizer *swipe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)]; // 控制识别的手势方向, 默认识别从左往右, 此处改为从右往左 swipe.</description>
    </item>
    
    <item>
      <title>信号量实现 NSURLSession 的同步请求</title>
      <link>https://jepphu.github.io/2019/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0nsurlsession%E7%9A%84%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Thu, 07 Mar 2019 18:46:19 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0nsurlsession%E7%9A%84%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82/</guid>
      <description>NSURLSession 只有异步请求
通过信号量来实现同步
NSURL *url = [NSURL URLWithString:@&amp;quot;https://jepphu.github.io/&amp;quot;]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; [request setHTTPMethod:@&amp;quot;GET&amp;quot;]; NSLog(@&amp;quot;1 -- %@&amp;quot;,[NSThread currentThread]); __block NSURLResponse *resultResponse; __block NSError *resultError; __block NSData *resultData; //创建信号量 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); NSURLSessionTask *task = [[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { resultResponse = response; resultError = error; resultData = data; NSLog(@&amp;quot;2 -- %@&amp;quot;,[NSThread currentThread]); //发送信号 dispatch_semaphore_signal(semaphore); }]; [task resume]; //等待 dispatch_semaphore_wait(semaphore,DISPATCH_TIME_FOREVER); NSLog(@&amp;quot;3 -- %@&amp;quot;,[NSThread currentThread]);  </description>
    </item>
    
    <item>
      <title>UIImageView 的 contentMode 属性</title>
      <link>https://jepphu.github.io/2019/uiimageview/</link>
      <pubDate>Tue, 05 Mar 2019 20:11:26 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/uiimageview/</guid>
      <description> contentMode UIViewContentModeScaleToFill, // 默认，对图片进行拉伸处理，不按比例充满 bounds UIViewContentModeScaleAspectFit, // 按原图比例进行拉伸，图片完全展示在 bounds 中，会留白，不会裁剪 UIViewContentModeScaleAspectFill, // 按原图比例填充，使图片展示在bouns中，可能会被裁剪 UIViewContentModeRedraw, // 原图重新绘制在 bounds 内，充满 (calls -setNeedsDisplay) UIViewContentModeCenter, // 图片显示在 imageview 的正中间，原图大小，可能会被裁剪 UIViewContentModeTop, // 图片从 imageview 的上部开始显示，原图大小，可能会被裁剪 UIViewContentModeBottom, // 图片从 imageview 的下部开始显示，原图大小，可能会被裁剪 UIViewContentModeLeft, // 图片从 imageview 的左部开始显示，原图大小，可能会被裁剪 UIViewContentModeRight, // 图片从 imageview 的右部开始显示，原图大小，可能会被裁剪 UIViewContentModeTopLeft, // 图片从 imageview 的左上部开始显示，原图大小，可能会被裁剪 UIViewContentModeTopRight, // 图片从 imageview 的右上部开始显示，原图大小，可能会被裁剪 UIViewContentModeBottomLeft, // 图片从 imageview 的左下部开始显示，原图大小，可能会被裁剪 UIViewContentModeBottomRight, // 图片从 imageview 的右下部开始显示，原图大小，可能会被裁剪  </description>
    </item>
    
    <item>
      <title>iOS 原生分享</title>
      <link>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</guid>
      <description>优点：使用简单，不用注册分享平台账号，不用导入的 SDK 包
缺点：只能使用系统提供的固定样式，分享的类型受限，只能分享 text、url、image
NSArray *arr = @[result]; UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:arr applicationActivities:nil]; activityVC.completionWithItemsHandler = ^(UIActivityType _Nullable activityType, BOOL completed, NSArray * _Nullable returnedItems, NSError * _Nullable activityError) { if (completed) { NSLog(@&amp;quot;share completed&amp;quot;); } else { NSLog(@&amp;quot;share failed&amp;quot;); } }; [self presentViewController:activityVC animated:YES completion:nil];  arr 支持 UIActivity 类型，可以创建自定义的 Activity，同时分享 NSString，UIImage，NSURL</description>
    </item>
    
    <item>
      <title>git 配置多账户</title>
      <link>https://jepphu.github.io/2019/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E6%88%B7/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E6%88%B7/</guid>
      <description>1. 为不同的账号生成对应的 key 检查是否有 .ssh 目录
cd ~/.ssh #如果目录不存在，执行 ssh-keygen  生成 github 和 bitbucket 的 key
cd ~/.ssh ssh-keygen -t rsa -C &amp;quot;youremail@domain.com&amp;quot; #执行命令后的第一次输入，输入一个用于区分的自定义名字,不要有空格，如：my_github_rsa，回车 第二次与第三次的输入是为了设定访问 key 的密码，可以直接回车跳过 ssh-keygen -t rsa -C &amp;quot;youremail@domain.com&amp;quot; #同上自定义名字，如：my_bitbucket_rsa  此时在 .ssh 目录下至少会有以下5个文件，.pub 后缀的为公钥，另一个为秘钥
config my_bitbucket_rsa my_github_rsa my_bitbucket_rsa.pub my_github_rsa.pub  2. 修改配置文件 #进入 .ssh 目录，如果目录下没有 config 文件，那么创建 cd ~/.ssh touch config #添加以下内容 Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/my_github_rsa Host bitbucket.org HostName bitbucket.org PreferredAuthentications publickey IdentityFile ~/.</description>
    </item>
    
    <item>
      <title>BaiduPCS Go</title>
      <link>https://jepphu.github.io/2019/baidupcs-go/</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/baidupcs-go/</guid>
      <description> BaiduPCS Go 用于从百度云盘下载文件的工具
#登录百度帐号 BaiduPCS-Go login #列出&amp;lt;文件或目录&amp;gt; BaiduPCS-Go ls #下载文件/目录 BaiduPCS-Go download &amp;lt;文件或目录&amp;gt;  #列出所有已登录的百度帐号 BaiduPCS-Go loglist #获取当前帐号 BaiduPCS-Go who #切换已登录的百度帐号 BaiduPCS-Go su &amp;lt;uid&amp;gt; #退出当前登录的百度帐号 BaiduPCS-Go logout  </description>
    </item>
    
    <item>
      <title>SFSafariViewController</title>
      <link>https://jepphu.github.io/2018/sfsafariviewcontroller/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/sfsafariviewcontroller/</guid>
      <description>不用跳出 app，直接在 app 内打开隐私协议等网址
#import &amp;lt;SafariServices/SafariServices.h&amp;gt;  &amp;lt;SFSafariViewControllerDelegate&amp;gt;  - (IBAction)action:(id)sender { NSURL *url = [NSURL URLWithString:@&amp;quot;https://jepphu.github.io/&amp;quot;]; SFSafariViewController *safariVC = [[SFSafariViewController alloc] initWithURL:url]; safariVC.delegate = self; // self.navigationController.navigationBarHidden = YES; // [self.navigationController pushViewController:safariVC animated:YES]; [self presentViewController:safariVC animated:YES completion:nil]; } // 加载完成 - (void)safariViewController:(SFSafariViewController *)controller didCompleteInitialLoad:(BOOL)didLoadSuccessfully { } // 按钮 Done - (void)safariViewControllerDidFinish:(SFSafariViewController *)controller { }  </description>
    </item>
    
    <item>
      <title>网络基础</title>
      <link>https://jepphu.github.io/2018/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 25 Sep 2018 17:00:00 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
      <description>网络基本概念  客户端（前端）：应用
 服务器（后端）：为客户端提供服务、数据和资源的机器
 请求：客户端向服务器索取数据
 响应：服务器对客户端的请求作出反应，一般是服务器从数据库获得数据，然后返回给客户端
 C/S : Client/Server
 B/S : Browser/Server
  服务器  内网服务器：局域网内部的服务器
 外网服务器：所有用户通过互联网能访问到的服务器
 本地测试服务器：简化开发过程，在本地搭建一个服务器，用于测试
  URL  URL : Uniform Resource Locatora，统一资源定位符
网络中每一个资源都对应唯一的地址-URL
 URL 的基本格式：协议://主机地址:端口号/路径
 协议：不同的协议代表不同的资源获取方式
 主机地址：主机的唯一标示（IP地址，域名）
 路径：资源在主机中的具体位置
  URL 常见协议
 http ：HyperText Transfer Protocol，超文本传输协议
 ftp ：文件传输协议
 mailto ：电子邮件协议
 file ：本地文件传输协议
 tel ：电话
 sms ：短信</description>
    </item>
    
    <item>
      <title>UINavigationBar</title>
      <link>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</guid>
      <description>UINavgationBar 设置颜色 UINavigationController *nav = self.navigationController; nav.navigationBar.tintColor = [UIColor whiteColor]; nav.navigationBar.barTintColor = [UIColor colorWithRed:28/255.0 green:152/255.0 blue:225/255.0 alpha:1.0]; nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor whiteColor]};  此时会觉得 navigationbar 颜色很浅，因为这是半透明状态
默认 navigationbar.translucent = YES
改为 navigationbar.translucent = NO
颜色问题解决，但是子控制器视图整体下移，加上下面这句
self.extendedLayoutIncludesOpaqueBars = YES;
或者在 storyboard 中 viewController 属性勾选 Under Opaque Bars
如果有特殊需求，尝试使用下面的方法
透明化和显示 UINavigationBar 以及 UINavigationBar 底部的线  方法1：  - (UIImageView *)navigationBarLineUnder:(UIView *)navigationBar { if ([navigationBar isKindOfClass:[UIImageView class]] &amp;amp;&amp;amp; navigationBar.bounds.size.height &amp;lt;= 1.0) { return (UIImageView *)navigationBar; } for (UIView *subview in navigationBar.</description>
    </item>
    
    <item>
      <title>present 一个 navigation</title>
      <link>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</guid>
      <description>在 present 页面之后的页面需要使用 navigation
UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:logInVC]; nav.navigationBar.tintColor = [UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0]; nav.navigationBar.barTintColor = [UIColor whiteColor]; nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0]}; [self presentViewController:nav animated:NO completion:nil];  为 present 出来的 navigation 添加返回按钮
if (self.navigationController.navigationItem.hidesBackButton) { self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&amp;quot;Back&amp;quot; style:UIBarButtonItemStylePlain target:self action:@selector(dismissVC)]; } - (void)dismissVC { [self dismissViewControllerAnimated:YES completion:nil]; }  </description>
    </item>
    
    <item>
      <title>image 绘制、裁剪、水印、保存</title>
      <link>https://jepphu.github.io/2018/image%E7%BB%98%E5%88%B6%E8%A3%81%E5%89%AA%E6%B0%B4%E5%8D%B0%E4%BF%9D%E5%AD%98/</link>
      <pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/image%E7%BB%98%E5%88%B6%E8%A3%81%E5%89%AA%E6%B0%B4%E5%8D%B0%E4%BF%9D%E5%AD%98/</guid>
      <description>绘制空白的 image UIColor *color = [UIColor whiteColor]; CGSize size = CGSizeMake(300, 300); // 开启图片上下文 // UIGraphicsBeginImageContext(size); // 第三个参数 创建的图片根据屏幕的缩放比例来生成 两倍 或 三倍 像素大小 // 第三个参数 传 0 等同于 [UIScreen mainScreen].scale UIGraphicsBeginImageContextWithOptions(size, NO, 0); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, color.CGColor); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();  裁剪图片 UIImage *image = [UIImage imageNamed:@&amp;quot;me&amp;quot;]; UIGraphicsBeginImageContextWithOptions(image.size, NO, 0); CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextAddArc(ctx, image.size.width * 0.5, image.size.height * 0.5, image.size.width * 0.</description>
    </item>
    
    <item>
      <title>App 发送邮件</title>
      <link>https://jepphu.github.io/2018/app%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/app%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</guid>
      <description>iOS App 发送邮件 #import &amp;lt;MessageUI/MessageUI.h&amp;gt;  &amp;lt;MFMailComposeViewControllerDelegate&amp;gt;  [self sendEmail:@&amp;quot;jepp.hu@mail.com&amp;quot;];  - (void)sendEmail:(NSString *)email { if ([MFMailComposeViewController canSendMail]) { // [self.navigationController presentViewController:[self configuredMailComposeViewControllerWithEmail:email] animated:YES completion:nil]; [self presentViewController:[self configuredMailComposeViewControllerWithEmail:email] animated:YES completion:nil]; } else { UIAlertController *sendMailErrorAlert = [UIAlertController alertControllerWithTitle:@&amp;quot;Can not send&amp;quot; message:@&amp;quot;Please set your email&amp;quot; preferredStyle:UIAlertControllerStyleAlert]; [sendMailErrorAlert addAction:[UIAlertAction actionWithTitle:@&amp;quot;OK&amp;quot; style:UIAlertActionStyleDefault handler:nil]]; // [self.navigationController presentViewController:sendMailErrorAlert animated:YES completion:nil]; [self presentViewController:sendMailErrorAlert animated:YES completion:nil]; } } - (MFMailComposeViewController *)configuredMailComposeViewControllerWithEmail:(NSString *)email { MFMailComposeViewController *mfVC = [[MFMailComposeViewController alloc] init]; mfVC.</description>
    </item>
    
    <item>
      <title>iOS 约束布局与动画</title>
      <link>https://jepphu.github.io/2018/ios%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Sun, 10 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/ios%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8A%A8%E7%94%BB/</guid>
      <description>在控件被添加了约束的情况下，修改 frame 是无法实现的动画的
 修改约束的值 调用 layoutIfNeeded，要注意调用时机  self.viewHeight.constant = 0; [UIView animateWithDuration:0.25 animations:^{ [self.view layoutIfNeeded]; }];  </description>
    </item>
    
    <item>
      <title>UIButton 设置背景图片</title>
      <link>https://jepphu.github.io/2018/uibutton%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uibutton%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</guid>
      <description>背景图自适应尺寸拉伸
[button setBackgroundImage:image forState:UIControlStateNormal];
背景图不拉伸
[button setImage:image forState:UIControlStateNormal];
关闭按钮点击时高亮的效果, 但是高亮的状态还在,只是效果没了
button.adjustsImageWhenDisabled = NO;</description>
    </item>
    
    <item>
      <title>UIImage 渲染</title>
      <link>https://jepphu.github.io/2018/uiimage%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiimage%E6%B8%B2%E6%9F%93/</guid>
      <description>UIImage 有个 UIImageRenderingMode 属性，默认为 UIImageRenderingModeAutomatic
- (UIImage *)imageWithRenderingMode:(UIImageRenderingMode)renderingMode; typedef NS_ENUM(NSInteger, UIImageRenderingMode) { UIImageRenderingModeAutomatic, // 根据图片所处的绘图上下文自动调整渲染模式 UIImageRenderingModeAlwaysOriginal, // 始终绘制图片原始状态，不使用 Tint Color 渲染 UIImageRenderingModeAlwaysTemplate, // 始终根据环境的 Tint Color 渲染图片，忽略图片的本身的颜色信息 }  这个属性会导致一个常见的问题：UITabBarItem 上的 image 颜色与设置的原图不同 让 image 保持原图不被渲染有两种方法
 代码设置，这个只是局部的修改  UIImage *leftImage = [[UIImage imageNamed:@&amp;quot;icon_s&amp;quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; self.navigationItem.leftBarButtonItem.image = leftImage;   进入 Assets.xcassets，找到图片资源，在属性栏中有 Render As 属性，选中 Original Image  在整个工程中，使用到这个 image 都不会被环境的 Tint Color 渲染
可以利用这个属性来将 image 渲染成想要的颜色 设置环境的 Tint Color，</description>
    </item>
    
    <item>
      <title>UIView 事件拦截</title>
      <link>https://jepphu.github.io/2018/uiview%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiview%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/</guid>
      <description>hitTest: 方法会递归来寻找第一响应者  判断 point 是否在自身范围内，不在则返回 nil，在则执行第 2 步 检查 subViews，判断 point 是否在 subView 范围内，在则返回 subView（此时 subView 成为第一响应者，subView会执行 hitTest:） 如果所有 subViews 都不包含 point，只有自身包含（第1步）那就返回 self（自身成为第一响应者）  subViews 上的事件全部由父 View 来实现 重写父级 View 的 hitTest 方法，返回 self，自身成为第一响应者
subViews 的 touch 相关方法不会响应
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{ // 直接返回 self 这样自身就成为了第一响应者 subViews 不能够接受到响应事件 if (CGRectContainsPoint(self.bounds, point)) { return self; } return nil; }  允许部分 subViews 响应事件 重写父级 View 的 hitTest 方法，返回某个 subView，subView 成为第一响应者</description>
    </item>
    
    <item>
      <title>UIView 子视图坐标转换</title>
      <link>https://jepphu.github.io/2018/uiview%E5%AD%90%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiview%E5%AD%90%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</guid>
      <description>ViewA, ViewB, ViewC
ViewA 是 ViewB 的父视图，ViewB 是 ViewC 的父视图
ViewC 此时的 frame 是相对于 ViewB 的
如果需求为获取 ViewC 此时相对于 ViewA 的 frame
- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view; - (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view; CGRect frame = [ViewB convertRect:ViewC.frame toView:ViewA]; //或 CGRect frame = [ViewA convertRect:ViewC.frame fromView:ViewB];  </description>
    </item>
    
    <item>
      <title>收回键盘</title>
      <link>https://jepphu.github.io/2018/%E6%94%B6%E5%9B%9E%E9%94%AE%E7%9B%98/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E6%94%B6%E5%9B%9E%E9%94%AE%E7%9B%98/</guid>
      <description>收回键盘主要调用方法：
[self.view endEditing:YES] //或 [self.emailTextField resignFirstResponder]   ViewController :  - (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event { [self.view endEditing:YES]; }   TableViewController :  - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{ [self.view endEditing:YES]; }  // 弹出键盘
[self.textField becomeFirstResponder]  </description>
    </item>
    
    <item>
      <title>UITableViewCell 改变选时中颜色</title>
      <link>https://jepphu.github.io/2018/uitableviewcell%E6%94%B9%E5%8F%98%E9%80%89%E6%97%B6%E4%B8%AD%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uitableviewcell%E6%94%B9%E5%8F%98%E9%80%89%E6%97%B6%E4%B8%AD%E9%A2%9C%E8%89%B2/</guid>
      <description>TableViewCell 有一个 selectedBackgroundView 属性
创建一个 View 设为 selectedBackgroundView，就可以改变选中状态下的 cell
UIView *view = [[UIView alloc] initWithFrame:self.bounds]; view.backgroundColor = [UIColor whiteColor]; self.selectedBackgroundView = view;  </description>
    </item>
    
    <item>
      <title>Runtime</title>
      <link>https://jepphu.github.io/2018/runtime/</link>
      <pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/runtime/</guid>
      <description>Runtime Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制，而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库
它是 OC 面向对象和动态机制的基石
OC 将数据类型的确定由编译时推迟到了运行时
OC 代码也会在运行时转化成 C 语言代码
作用 例如，分类可以加属性，但是自己写 set/get，没法增加成员变量
通过 Runtime
 可以在运行期间给某个分类增加属性、方法
 可以在运行期间获取某个对象的所有属性名称
 交换方法
  引入头文件
#import &amp;lt;objc/runtime.h&amp;gt;  为系统的 UIImageView，写一个分类，增加一个成员变量
@interface UIImageView (MyView) @property (copy, nonatomic) NSString *urlString; @end  @implementation UIImageView (MyView) - (NSString *)urlString { return objc_getAssociatedObject(self, &amp;quot;str&amp;quot;); } - (void)setUrlString:(NSString *)urlString { //关联对象(给类增加属性) //参数1: 对象 //参数2: 属性的名称(C的字符串) //参数3: 属性的值 //参数3: 属性的修饰符 (copy, nonatomic) objc_setAssociatedObject(self, &amp;quot;str&amp;quot;, urlString, OBJC_ASSOCIATION_COPY_NONATOMIC); } @end  成功访问到这个属性</description>
    </item>
    
    <item>
      <title>NSOperation 与 GCD 优劣</title>
      <link>https://jepphu.github.io/2018/nsoperation%E4%B8%8Egcd%E4%BC%98%E5%8A%A3/</link>
      <pubDate>Mon, 16 Apr 2018 21:00:00 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2018/nsoperation%E4%B8%8Egcd%E4%BC%98%E5%8A%A3/</guid>
      <description>NSOperation 特有的操作  NSOperationQueue 设置最大并发数 （同时执行的任务的个数）
 队列的暂停与继续，以及取消所有的操作
 指定操作之前的依赖关系（GCD可以用同步实现）
  - (NSOperationQueue *)queue { if (!_queue) { _queue = [[NSOperationQueue alloc] init]; //最大并发数 [_queue setMaxConcurrentOperationCount:2]; } return _queue; }  // 这里不是线程越多越好, 应该设置最大并发数(不是多开启线程数) for (int i = 0; i &amp;lt; 10; i ++) { [self.queue addOperationWithBlock:^{ [NSThread sleepForTimeInterval:2]; NSLog(@&amp;quot;%d -- %@&amp;quot;, i, [NSThread currentThread]); }]; }  队列的取消/暂停/继续
// 当前操作会继续执行, 后续操作才会取消, 会从队列中移除 [self.queue cancelAllOperations]; // 当前操作会继续执行, 后续操作才会暂停, self.</description>
    </item>
    
    <item>
      <title>自定义 NSOperation</title>
      <link>https://jepphu.github.io/2018/%E8%87%AA%E5%AE%9A%E4%B9%89nsoperation/</link>
      <pubDate>Mon, 16 Apr 2018 20:00:00 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E8%87%AA%E5%AE%9A%E4%B9%89nsoperation/</guid>
      <description>自定义 NSOperation NSInvocationOperation : 指定一个方法
NSBlockOperation : 指定一个block
自定义 Operation : 封装一个操作（下载）， 将具体操作写在操作的 main 方法里面
@interface MyDownloadOperation : NSOperation @property (copy, nonatomic) NSString *urlString; @property (copy, nonatomic) void (^finishedBlock)(UIImage *); + (instancetype)downloadOperationWithUrlString:(NSString *)urlString finishedBlock:(void(^)(UIImage *img))finishedBlock;  @implementation MyDownloadOperation + (instancetype)downloadOperationWithUrlString:(NSString *)urlString finishedBlock:(void (^)(UIImage *))finishedBlock { MyDownloadOperation *op = [[self alloc] init]; op.urlString = urlString; op.finishedBlock = finishedBlock; return op; } //直接将操作写在 main 方法里面 (), 等同于 NSInvocationOperation 指定了一个方法和 NSBlockOperation 指定一个 block 一样 - (void)main { @autoreleasepool {//子线程无法访问主线程的自动释放池, 所以让子线程拥有自己的自动释放池 //耗时操作 [NSThread sleepForTimeInterval:2]; //将下载的文件保存到沙盒中 //取消正在执行的操作 if (self.</description>
    </item>
    
    <item>
      <title>NSOperation</title>
      <link>https://jepphu.github.io/2018/nsoperation/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/nsoperation/</guid>
      <description>NSOperation: 任务（这里又叫操作） NSOperation 是一个抽象类、父类，用来约束子类
子类：NSInvocationOperation，NSBlockOperation，还可以自定义子类
NSOperationQueue：队列 @property (strong, nonatomic) NSOperationQueue *queue; - (NSOperationQueue *)queue { if (!_queue) { _queue = [[NSOperationQueue alloc] init]; } return _queue; }  当前队列中的操作数
self.queue.operationCount  操作暂停：暂停不会立即暂停, 会先执行完当前的操作
self.queue.suspended = YES;  结束暂停：不结束暂停状态是无法向队列添加操作的
self.queue.suspended = NO;  NSInvocationOperation 指定一个方法 // 创建操作 NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil]; // [op start]; //不会开启线程, 会执行内部的 main 方法, 并改变 op 的 finished 状态；详见自定义NSOperation // 创建新队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 将操作添加到队列 (会开启新线程, 并执行方法) [queue addOperation:op];  NSBlockOperation 指定一个block 用法 1:</description>
    </item>
    
    <item>
      <title>NSRunLoop</title>
      <link>https://jepphu.github.io/2018/nsrunloop/</link>
      <pubDate>Tue, 03 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/nsrunloop/</guid>
      <description>NSRunLoop：消息循环机制 线程与 RunLoop 是一一对应的
有线程，才能开启线程中对应 RunLoop
主线程的 RunLoop 是默认开启的，而子线程中的 RunLoop 是默认关闭的
开启了 RunLoop 的线程才不会在执行完队列任务被回收
所以主线程可以一直运行而不会结束
NSRunLoop 保证线程不会被退出，并且能在不处理消息的时候让线程休眠，节约资源，在接收到消息的时候唤醒线程做出对应处理并接收各种消息和处理各种事件
获取 RunLoop 苹果不直接创建 RunLoop，只能获取
RunLoop 是懒加载，在第一次获取时创建，在线程结束时销毁
// 获取当前线程的RunLoop [NSRunLoop currentRunLoop]; [NSRunLoop mainRunLoop]; CFRunLoopGetMain(); CFRunLoopGetCurrent();  启动 RunLoop // 默认 NSDefaultRunLoopMode [[NSRunLoop currentRunLoop] run]; // 默认 NSDefaultRunLoopMode，消息循环一直运行, 2秒后结束 [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]]; // 指定运行模式，在时间到后或者触发了非 Timer 的事件后退出。 [[NSRunLoop currentRunLoop] runMode:NSRunLoopCommonModes beforeDate:[NSDate dateWithTimeIntervalSinceNow:2]];  启动 RunLoop 时必须指定一种 mode
NSDefaultRunLoopMode // 默认模式, 可以处理输入源 UITrackingRunloopMode // 界面跟踪模式，用于 scrollView, textView 追踪触摸，界面滑动时不受其他 mode 影响 UIinitializationRunloopMode // 在 App 启动进入被主线程使用的第一个 mode，启动完成后就不再使用 GSEventRecieveRunloopMode // 苹果使用绘图相关 NSRunLoopCommonModes // 混合模式, 是一个集合, 包含了NSDefaultRunLoopMode, UITrackingRunLoopMode等  mode 有三个组成部分 Source（事件源），Timer（定时器）以及 Observor（观察者）</description>
    </item>
    
    <item>
      <title>GCD</title>
      <link>https://jepphu.github.io/2018/gcd/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/gcd/</guid>
      <description>GCD : Grand Central Dispatch  任务: block，确认执行什么任务
 队列: queue，用来存放任务，并行或串行
 执行方式：同步，不开线程；异步，开启线程
   创建队列 创建任务 将任务添加到队列并执行  // 创建队列 (全局队列，实际上是获取到全局队列) dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // 创建任务 dispatch_block_t task = ^{ NSLog(@&amp;quot;%@&amp;quot;, [NSThread currentThread]); }; // 将任务添加到队列并执行 // 异步执行, 开启了新的线程 dispatch_async(queue, task); // 同步执行, 仍然在当前线程上(不一定是主线程)执行任务, 不会开新的线程 dispatch_sync(queue, task);  队列  并行队列：只在异步执行有效，自动开启多个线程同时执行任务
 串行队列：让任务一个接一个的执行，只会在一个线程中执行完队列中的任务
 主队列：主线程中的队列
 全局队列：本质是并行队列，只是全局队列没有名称，没办法跟踪错误，并行队列则有名称；全局队列一直存在, 不用自己创建, 只需要获取;
  dispatch_get_global_queue(&amp;lt;#long identifier#&amp;gt;, &amp;lt;#unsigned long flags#&amp;gt;) &amp;lt;#long identifier#&amp;gt; : 服务质量, 也就是并发优先级，0 &amp;lt;#unsigned long flags#&amp;gt; : 这个参数没有作用, 苹果留用, 固定为 0  多线程通常使用 全局队列</description>
    </item>
    
    <item>
      <title>GCD Time</title>
      <link>https://jepphu.github.io/2018/gcd_time/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/gcd_time/</guid>
      <description> 延迟执行 // 参数1: 延迟多少时间, 精度到 纳秒 // 参数2: 队列 // 参数3: 任务 double second = 3.0; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(second * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&amp;quot;延迟 %f&amp;quot;, second); });  定时器 dispatch_source </description>
    </item>
    
    <item>
      <title>GCD barrier 阻塞与调度组</title>
      <link>https://jepphu.github.io/2018/gcd_barrier%E9%98%BB%E5%A1%9E/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/gcd_barrier%E9%98%BB%E5%A1%9E/</guid>
      <description>需求：开启 N 个子线程执行任务，但是后面需要依赖 N 个子线程的任务结果才能继续操作
可以使用 barrier 或 调度组
barrier 主要用于在多个异步操作完成之后，统一对非线程安全的对象进行更新，适合于大规模的 I/O 操作
当访问数据库或文件时，更新数据的时候不能和其他更新和读取的操作在同一时间执行
@interface ViewController () { dispatch_queue_t _queue; } @property (strong, nonatomic) NSMutableArray *photoList; @end - (NSMutableArray *)photoList { if (!_photoList) { _photoList = [NSMutableArray array]; } return _photoList; } - (void)viewDidLoad { [super viewDidLoad]; // 创建并发队列，不能使用全局队列, 要用手动创建并发队列 _queue = dispatch_queue_create(&amp;quot;for barrier&amp;quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &amp;lt; 10; i ++) { [self getImage:i]; } } - (void)getImage:(int)index { // 异步执行并发队列，创建多个子线程执行任务 queue = dispatch_queue_create(&amp;quot;for barrier&amp;quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(_queue, ^{ NSString *fileName = [NSString stringWithFormat:@&amp;quot;%02d&amp;quot;, index % 10]; NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&amp;quot;png&amp;quot;]; UIImage *image = [UIImage imageWithContentsOfFile:path]; // 多线程，同一时刻向 photoList 添加元素，可能会造成丢失，崩溃，这个时候需要添加阻塞，且不能使用全局队列, 要用手动创建并发队列 // 阻塞所有的线程, 直到队列任务都完成后才执行这个段代码, 最后才来添加 dispatch_barrier_async(self-&amp;gt;_queue, ^{ [self.</description>
    </item>
    
    <item>
      <title>GCD 单例</title>
      <link>https://jepphu.github.io/2018/gcd%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/gcd%E5%8D%95%E4%BE%8B/</guid>
      <description>dispach_once dispach_once 函数中的代码块只会被执行一次，而且还是线程安全的
@interface Person : NSObject + (instancetype)sharePerson; @end  @implementation Person + (instancetype)allocWithZone:(struct _NSZone *)zone { static Person *instance = nil; // 一次性执行 static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ instance = [super allocWithZone:zone]; }); return instance; } + (instancetype)sharePerson { return [self new]; }  快速实现单例 封装到头文件
// 创建单例, 禁用 alloc, new, copy, mutableCopy 方法 #define SINGLETON_DEF(_type_) + (_type_ *)sharedInstance;\ +(instancetype) alloc __attribute__((unavailable(&amp;quot;call sharedInstance instead&amp;quot;)));\ +(instancetype) new __attribute__((unavailable(&amp;quot;call sharedInstance instead&amp;quot;)));\ -(instancetype) copy __attribute__((unavailable(&amp;quot;call sharedInstance instead&amp;quot;)));\ -(instancetype) mutableCopy __attribute__((unavailable(&amp;quot;call sharedInstance instead&amp;quot;)));\ // 实现单例 #define SINGLETON_IMP(_type_) + (_type_ *)sharedInstance {\ static _type_ *sharedInstance = nil;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;amp;onceToken, ^{\ sharedInstance = [[super alloc] init];\ });\ return sharedInstance;\ }  声明</description>
    </item>
    
    <item>
      <title>NSThread</title>
      <link>https://jepphu.github.io/2018/nsthread/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/nsthread/</guid>
      <description> 多线程 多线程是切换执行的, 切换的速度非常快, 接近于 &amp;ldquo;同时&amp;rdquo; 执行, 实际上每个线程执行一段时间片就切换
程序执行过程中系统会生成一些辅助线程, 且会自动销毁
NSThread 生命周期需要程序员管理
NSThread 的使用方式 方式 1
// NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(demo:) object:@&amp;quot;obj&amp;quot;]; // 线程名字 thread1.name = @&amp;quot;t1&amp;quot;; // 线程的优先级,默认 0.5, 取值范围 (0 ~ 1), 可以使被分配时间片的几率更大, 但是不能保证一定先执行完 thread1.threadPriority = 1; // 线程进入可执行状态, 等待被调度, 执行 [thread1 start];  方式 2
[NSThread detachNewThreadSelector:@selector(demo) toTarget:self withObject:nil];  方式 3
[self performSelectorInBackground:@selector(demo) withObject:nil];  调用方法
- (void)demo:(NSString *)sender { NSLog(@&amp;quot;name : %@&amp;quot;, name); for (int i = 0; i &amp;lt; 20; i ++) { NSLog(@&amp;quot;%@&amp;quot;, [NSThread currentThread]); // 阻塞线程 [NSThread sleepForTimeInterval:1]; } [NSThread exit]; }  </description>
    </item>
    
    <item>
      <title>多线程与锁</title>
      <link>https://jepphu.github.io/2018/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</guid>
      <description>atomic 原子属性 多个线程同时读写这个属性时, 上了一把自旋锁,
 自旋锁: 单写多读, 单个线程写入, 但是允许多个线程读取
所以这样多线程读仍然会导致数据错误
如果线程正在锁定代码, 其他线程的写入操作会用死循环的方式一直等待锁定的代码执行完毕, 自旋锁更适合执行不耗时的代码
 互斥锁
想读写完全绑定, 只能用互斥锁
如果线程正在锁定代码, 其他线程的会进入就绪状态(休眠,等待执行), 等到锁打开后, 线程被唤醒
  nonatomic 非原子属性 没有锁, 但是性能高
@property (assign, nonatomic) int ticketsCount;  上互斥锁
// 模拟多窗口卖票的操作 self.ticketsCount = 10; //多线程执行卖票操作, 这样会造成数据错误, 需要将单个线程读写操作绑定在一起, 使两者不能不可分割(原子性), [NSThread detachNewThreadSelector:@selector(sellTickets) toTarget:self withObject:nil]; [NSThread detachNewThreadSelector:@selector(sellTickets) toTarget:self withObject:nil];  - (void)sellTickets { while (YES) { // 模拟耗时操作 [NSThread sleepForTimeInterval:1.0]; //上互斥锁, 将单个线程读写操作绑定在一起, 使两者不能不可分割(原子性) //实现线程同步, 让线程在这里按顺序执行(会影响程序性能) //锁是 NSObject 的一个对象, 默认打开, 进入代码块将上锁 @synchronized(self) { if (self.</description>
    </item>
    
    <item>
      <title>NSTableView</title>
      <link>https://jepphu.github.io/2018/nstableview/</link>
      <pubDate>Wed, 07 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/nstableview/</guid>
      <description>NSTableView &amp;lt;NSTableViewDelegate,NSTableViewDataSource&amp;gt;  self.tableView.delegate = self; self.tableView.dataSource = self;  - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row{ return 30; } - (NSInteger)numberOfRowsInTableView:(NSTableView *)tableView{ return self.tableContents.count; } // 创建一个 NSTableRowView，它会是 NSTableCellView 的父级 // 可以用来控制 row 被选中后的呈现的颜色 - (NSTableRowView *)tableView:(NSTableView *)tableView rowViewForRow:(NSInteger)row{ NSTableRowView *rowView = [tableView makeViewWithIdentifier:@&amp;quot;rowView_id_storyBoard&amp;quot; owner:nil]; return rowView; } - (NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row { NSTableCellView *cellView = [tableView makeViewWithIdentifier:@&amp;quot;cellView_id_storyBoard&amp;quot; owner:nil]; return cellView } // 选择一行时执行，此处可以获取上一个被选中的 row - (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(NSInteger)row { NSInteger lastSelectedRow = self.</description>
    </item>
    
    <item>
      <title>NSColorPanel</title>
      <link>https://jepphu.github.io/2018/nscolorpanel/</link>
      <pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/nscolorpanel/</guid>
      <description>设置 NSColorPanel 的显示模式和初始默认色盘，要在实例化之前设置
不自定义设置时会默认为以下设置
[NSColorPanel setPickerMask:NSColorPanelAllModesMask]; [NSColorPanel setPickerMode:NSColorPanelModeNone];  实例对象是一个单例
NSColorPanel *panel = [NSColorPanel sharedColorPanel];  显示与隐藏
if ([panel isVisible]) { [panel orderOut:self]; } else { [panel orderFront:self]; }  设置选取颜色后的响应事件
[panel setTarget:self]; [panel setAction:@selector(colorSelectedAction:)];  从 View 中拖拽颜色到颜色面板
- (void)mouseDragged:(NSEvent *)event { [NSColorPanel dragColor:[NSColor orangeColor] withEvent:event fromView:self]; }  </description>
    </item>
    
    <item>
      <title>NSView 监听鼠标悬停</title>
      <link>https://jepphu.github.io/2018/nsview%E7%9B%91%E5%90%AC%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C/</link>
      <pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/nsview%E7%9B%91%E5%90%AC%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C/</guid>
      <description>@interface HoverImageButton () @property (strong,nonatomic) NSTrackingArea *trackingArea; @property (strong,nonatomic) NSImage *tempImage; @property (strong,nonatomic) NSImage *alternateImage; @end  @implementation HoverImageButton - (instancetype)initWithCoder:(NSCoder *)coder { self = [super initWithCoder:coder]; if (self) { self.tempImage = self.image; } return self; } - (void)updateTrackingAreas { if (self.trackingArea) { [self removeTrackingArea:self.trackingArea]; } int opts = (NSTrackingActiveAlways | NSTrackingMouseEnteredAndExited); self.trackingArea = [[NSTrackingArea alloc] initWithRect:self.bounds options:opts owner:self userInfo:nil]; [self addTrackingArea:self.trackingArea]; } - (void)mouseEntered:(NSEvent *)event { [super mouseEntered:event]; self.image = self.</description>
    </item>
    
    <item>
      <title>NSWindow 改变 WindowButton 位置</title>
      <link>https://jepphu.github.io/2018/nswindow%E6%94%B9%E5%8F%98windowbutton%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Fri, 16 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/nswindow%E6%94%B9%E5%8F%98windowbutton%E4%BD%8D%E7%BD%AE/</guid>
      <description>NSWindow 上的三个按钮
NSButton *closeBtn = [self standardWindowButton:NSWindowCloseButton]; NSButton *miniaturizeBtn = [self standardWindowButton:NSWindowMiniaturizeButton]; NSButton *zoomBtn = [self standardWindowButton:NSWindowZoomButton];  系统创建的默认 frame 分别为
(7.000000,3.000000),(14.000000,16.000000) (27.000000,3.000000),(14.000000,16.000000) (47.000000,3.000000),(14.000000,16.000000)  button 创建时是自动布局，直接修改 frame 无效
关闭自动布局，添加约束布局就能修改 window button 的位置
closeBtn.translatesAutoresizingMaskIntoConstraints = NO; miniaturizeBtn.translatesAutoresizingMaskIntoConstraints = NO; zoomBtn.translatesAutoresizingMaskIntoConstraints = NO; NSLayoutConstraint *leftContraint1 = [NSLayoutConstraint constraintWithItem:closeBtn attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:closeBtn.superview attribute:NSLayoutAttributeLeft multiplier:1.0 constant:4.0]; NSLayoutConstraint *topContraint1 = [NSLayoutConstraint constraintWithItem:closeBtn attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:closeBtn.superview attribute:NSLayoutAttributeTop multiplier:1.0 constant:3.0]; leftContraint1.active = YES; topContraint1.active = YES; NSLayoutConstraint *leftContraint2 = [NSLayoutConstraint constraintWithItem:miniaturizeBtn attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:miniaturizeBtn.</description>
    </item>
    
    <item>
      <title>git 子模块</title>
      <link>https://jepphu.github.io/2018/git%E5%AD%90%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 14 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/git%E5%AD%90%E6%A8%A1%E5%9D%97/</guid>
      <description> 添加子模块 添加子模块，完成后会新增一个默认隐藏的配置文件 .gitmodules ，和一个外部项目的子目录 添加完成后需要将子模块切换到合适的分支
git submodule add 子项目地址（文件夹名称，可不填）  克隆一个带子模块的项目 克隆项目结束后之后，主目录下会包含子模块的空目录，进入主目录
git submodule init git submodule update  git 删除子模块  删除子模块目录及目录下的所有内容 .gitmodules 删除项目目录下.gitmodules文件中子模块相关条目 git/config 删除配置项中子模块相关条目 .git/module/* 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可  执行完成后，再执行添加子模块时报错，执行如下：
git rm --cached 子模块名称  </description>
    </item>
    
    <item>
      <title>重置 Dock 和 Launchpad</title>
      <link>https://jepphu.github.io/2018/%E9%87%8D%E7%BD%AEdock%E5%92%8Claunchpad/</link>
      <pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E9%87%8D%E7%BD%AEdock%E5%92%8Claunchpad/</guid>
      <description>用来解决 APP 图标异常的问题，APP 图标会恢复成默认排序
defaults write com.apple.dock ResetLaunchPad -bool true; killall Dock</description>
    </item>
    
    <item>
      <title>隐藏 Dock 应用图标和 Menu</title>
      <link>https://jepphu.github.io/2017/%E9%9A%90%E8%97%8Fdock%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E5%92%8Cmenu/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/%E9%9A%90%E8%97%8Fdock%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E5%92%8Cmenu/</guid>
      <description>Info.plist 设置字段：Application is agent (UIElement) 为 YES</description>
    </item>
    
    <item>
      <title>通过点击 Dock 图标重新显示窗口</title>
      <link>https://jepphu.github.io/2017/%E9%80%9A%E8%BF%87dock%E5%9B%BE%E6%A0%87%E9%87%8D%E6%96%B0%E6%98%BE%E7%A4%BA%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/%E9%80%9A%E8%BF%87dock%E5%9B%BE%E6%A0%87%E9%87%8D%E6%96%B0%E6%98%BE%E7%A4%BA%E7%AA%97%E5%8F%A3/</guid>
      <description>在 AppDelegate.m 文件中实现  中的方法：
- (BOOL)applicationShouldHandleReopen:(NSApplication *)sender hasVisibleWindows:(BOOL)flag { if (!flag){ [NSApp activateIgnoringOtherApps:NO]; [self.window makeKeyAndOrderFront:self]; } return YES; }  </description>
    </item>
    
    <item>
      <title>youtube-dl</title>
      <link>https://jepphu.github.io/2017/youtube-dl/</link>
      <pubDate>Thu, 21 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/youtube-dl/</guid>
      <description> youtube-dl 用于从 YouTube.com 等网站下载视频 安装
brew install youtube-dl  常用命令 youtube-dl [OPTIONS] URL [URL...] （URL 正在播放的视频网站链接） #输出版本号 youtube-dl --version #直接下载默认参数的视频 youtube-dl URL #获取所有可用视频格式 youtube-dl -F URL #使用代理端口下载视频 youtube-dl &amp;quot;https://127.0.0.1:1080&amp;quot; URL #帮助文本 youtube-dl --help #更新（如果提示需要权限，则在命令前面加上sudo） youtube-dl --update #下载过程中遇见错误，跳过错误，继续下载，例如跳过不可用的视频播放列表 youtube-dl --ignore-errors URL //或 youtube-dl -i URL #下载过程中发生错误，终止下载下一个视频 youtube-dl --abort-on-error URL #显示当前浏览器用于识别的ID youtube-dl --dump-user-agent URL #显示 youtube-dl 支持的网站的视频提取器 youtube-dl --list-extractors URL #显示 youtube-dl 支持的网站的视频提取器及对相关描述 youtube-dl --extractor-descriptions URL #强制使用通用网站视频提取器 youtube-dl --force-generic-extractor URL #不提取视频的播放列表，只提取视频 youtube-dl --flat-playlist URL  </description>
    </item>
    
    <item>
      <title>归档存储对象</title>
      <link>https://jepphu.github.io/2017/%E5%BD%92%E6%A1%A3%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 06 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/%E5%BD%92%E6%A1%A3%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1/</guid>
      <description>NSCoder 编码解码 让对象需要存储的类遵守  协议，然后在它的 .m 文件中实现协议方法，将属性编码解码  实现编码协议方法，将属性编码
 不是对象的属性通过 NSNumber 类转换为对象
 每一个对象分别提供一个唯一的字符串即键，一一进行编码
  - (void)encodeWithCoder:(NSCoder *)aCoder { [aCoder encodeObject:self.subject forKey:KEY_SUBJECT]; [aCoder encodeObject:self.fro forKey:KEY_FROM]; [aCoder encodeObject:[NSNumber numberWithBool:self.isFavorite] forKey:KEY_FAVORITE]; }   实现解码协议方法，将属性解码
 根据自己添加的键返回对象
 把这些对象和提取出来的数据一一赋给对应的属性
  - (instancetype)initWithCoder:(NSCoder *)aDecoder { self = [self init]; if (self) { self.subject = [aDecoder decodeObjectForKey:KEY_SUBJECT]; self.fro = [aDecoder decodeObjectForKey:KEY_FROM]; self.isFavorite = [[aDecoder decodeObjectForKey:KEY_FAVORITE] boolValue]; } return self; }  对象写入/读取 把对象写进指定的文件，写入成功则返回 YES，否则返回 NO</description>
    </item>
    
    <item>
      <title>NSBundle</title>
      <link>https://jepphu.github.io/2017/nsbundle/</link>
      <pubDate>Thu, 01 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/nsbundle/</guid>
      <description> 获取资源文件 NSString *bundlePath = [[NSBundle mainBundle] resourcePath]; NSString *imagePath = [[NSBundle mainBundle] pathForResource:@&amp;quot;imageName&amp;quot; ofType:@&amp;quot;png&amp;quot;];  从文件中读取数据 NSString *path = [[NSBundle mainBundle] pathForResource:@&amp;quot;MKStoreKitConfigs&amp;quot; ofType:@&amp;quot;plist&amp;quot;]; NSDictionary *dic = [[[NSDictionary alloc] initWithContentsOfFile:path]];  </description>
    </item>
    
    <item>
      <title>WKWebView 与 WebView 调试器</title>
      <link>https://jepphu.github.io/2017/wkwebview%E4%B8%8Ewebview%E8%B0%83%E8%AF%95%E5%99%A8/</link>
      <pubDate>Sun, 02 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/wkwebview%E4%B8%8Ewebview%E8%B0%83%E8%AF%95%E5%99%A8/</guid>
      <description> WKWebView #ifdef DEBUG [self.webView.configuration.preferences setValue:@YES forKey:@&amp;quot;developerExtrasEnabled&amp;quot;]; #endif  WebView #terminal defaults write com.yourcompany.yourbundleid WebKitDeveloperExtras TRUE  </description>
    </item>
    
    <item>
      <title>WKWebView 注入js、处理超链接和文件选择</title>
      <link>https://jepphu.github.io/2017/wkwebview-%E6%B3%A8%E5%85%A5js%E5%A4%84%E7%90%86%E8%B6%85%E9%93%BE%E6%8E%A5%E5%92%8C%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9/</link>
      <pubDate>Sun, 02 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/wkwebview-%E6%B3%A8%E5%85%A5js%E5%A4%84%E7%90%86%E8%B6%85%E9%93%BE%E6%8E%A5%E5%92%8C%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9/</guid>
      <description>&amp;lt;WKNavigationDelegate, WKUIDelegate&amp;gt;  self.webView.navigationDelegate = self; self.webView.UIDelegate = self;  注入 JavaScript 代码 NSString *path = [[NSBundle mainBundle]pathForResource:@&amp;quot;untitled&amp;quot; ofType:@&amp;quot;js&amp;quot;]; NSString *js = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; [webView evaluateJavaScript:js completionHandler:nil];  处理超链接，用浏览器打开 - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler { NSURL *url = navigationAction.request.URL; if (navigationAction.navigationType == WKNavigationTypeLinkActivated) { [[UIApplication sharedApplication] openURL:url]; // [[NSWorkspace sharedWorkspace] openURL:url]; decisionHandler(WKNavigationActionPolicyCancel); } else { decisionHandler(WKNavigationActionPolicyAllow); } }  处理网页中的文件选择 - (void)webView:(WKWebView *)webView runOpenPanelWithParameters:(WKOpenPanelParameters *)parameters initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSArray&amp;lt;NSURL *&amp;gt; * _Nullable))completionHandler { NSOpenPanel *panel = [NSOpenPanel openPanel]; [panel beginSheetModalForWindow:self.</description>
    </item>
    
    <item>
      <title>WKWebView 清除 cookies</title>
      <link>https://jepphu.github.io/2017/wkwebview%E6%B8%85%E9%99%A4cookies/</link>
      <pubDate>Sun, 02 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/wkwebview%E6%B8%85%E9%99%A4cookies/</guid>
      <description>NSSet *websiteDataTypes = [WKWebsiteDataStore allWebsiteDataTypes]; NSDate *dateFrom = [NSDate dateWithTimeIntervalSince1970:0]; [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteDataTypes modifiedSince:dateFrom completionHandler:^{}];  </description>
    </item>
    
    <item>
      <title>NSWindow 常用属性</title>
      <link>https://jepphu.github.io/2017/nswindow%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/nswindow%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/</guid>
      <description>隐藏标题栏
[self setTitleVisibility:NSWindowTitleHidden];  window StyleMask 设置为 NSFullSizeContentViewWindowMask 时，标题栏不绘制背景
[self setTitlebarAppearsTransparent:YES];  通过拖动背景来移动整个 window
[self setMovableByWindowBackground:YES];  完全透明的 window
[self setBackgroundColor:[NSColor clearColor]]; [self setOpaque:NO];  </description>
    </item>
    
    <item>
      <title>WKWebView 页面显示不全</title>
      <link>https://jepphu.github.io/2017/wkwebview%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/wkwebview%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8/</guid>
      <description> WKWebView 因为 NSWindow 属性造成的 bug NSWindowStyleMask == NSWindowStyleMaskFullSizeContentView  此时 WKWebView 如果不是充满整个 Window 加载的 HTML 会出现页面显示不全的情况
解决方法
NSWindowStyleMask == NSWindowStyleMaskBorderless  </description>
    </item>
    
    <item>
      <title>Finder 显示隐藏文件</title>
      <link>https://jepphu.github.io/2017/finder%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/finder%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</guid>
      <description>显示: defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder
隐藏: defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</description>
    </item>
    
    <item>
      <title>命令行操作目录与文件</title>
      <link>https://jepphu.github.io/2017/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6/</guid>
      <description>目录 创建目录 mkdir folderName
进入目录 cd folderName
返回上级目录 cd ..
删除空目录 rmdir folderName
强制删除目录及目录下的内容 rmdir -rf folderName
打开成可视化的文件夹 open folderName
打开当前目录 open .
文件 查看当前目录下的非隐藏文件 ls
查看当前目录下的所有文件 ls -a
创建文件 touch fileName.txt
删除文件 rm fileName.txt
复制文件 cp fileName.txt newName.txt
移动文件 mv fileName /zone/files/
重命名文件 mv fileName1 fileName2
查找当前目录下的所有 .txt 文件 find *.txt</description>
    </item>
    
    <item>
      <title>git 基础</title>
      <link>https://jepphu.github.io/2017/git%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2017/git%E5%9F%BA%E7%A1%80/</guid>
      <description>Git 配置用户名和邮箱 配置全局用户名和邮箱，不适用多账户
git config --global user.name &amp;quot;your name&amp;quot; git config --global user.email &amp;quot;your eamil@domain.com&amp;quot;  查看用户名和邮箱
git config user.name git config user.email  解除全局用户名和邮箱
git config --global --unset user.name git config --global --unset user.email  查看 git 所有配置
git config --list  上传本地项目到远程仓库  建立一个远程仓库 : git@github.com:xxx/xxx.git 进入项目根目录 初始化 git，并与远程仓库建立联系，将本地项目提交到远程仓库  git init git remote add origin git@github.com:xxx/xxx.git git add -A git commit -m &amp;quot;init&amp;quot; git push origin master // 如果 push 被拒绝, 则需要先 pull, pull 如果反应 refusing to merge unrelated histories git pull origin master --allow-unrelated-histories  克隆远程仓库的项目到本地  进入准备存放项目的根目录 将远程项目拉取到本地  git clone git@github.</description>
    </item>
    
    <item>
      <title>viewController 生命周期</title>
      <link>https://jepphu.github.io/2016/viewcontroller%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Wed, 28 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2016/viewcontroller%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>viewController 生命周期  viewController 的创建 （xib，storyBoard）
- (instancetype)initWithCoder:(NSCoder *)aDecoder;
 view 的创建
- (void)loadView;
 view 是懒加载的 只有系统认为需要生成一个 view 的时候，才会调用这个方法来创建一个 view，这个时候通常是 presentViewController: 或 pushViewController: 的时候 当只有 viewController 的初始化的时候，不会创建一个 view， 也不会走 - (void)viewDidLoad 想要不 presentViewController: 或 pushViewController: 的情况下创建 view，访问一下 view 即可，[ViewController view] 一但重写了 loadView，需要自己创建 view，这个时候可以生成一个 UIImageView , WKWebView 等其它 view    - (void)loadView { UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&amp;quot;Default&amp;quot;]]; imageView.frame = [UIScreen mainScreen].bounds; imageView.userInteractionEnabled = YES; self.</description>
    </item>
    
    <item>
      <title>Apache 服务启动和停止</title>
      <link>https://jepphu.github.io/2016/apache%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2016/apache%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2/</guid>
      <description>启动：sudo apachectl start
停止：sudo apachectl stop
重启：sudo apachectl restart
查看 Apache 版本 httpd -v
打开 http://127.0.0.1 可以看到 It works! 的页面，启动成功</description>
    </item>
    
  </channel>
</rss>