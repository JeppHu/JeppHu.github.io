<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jepp Hu on Jepp Hu</title>
    <link>https://jepphu.github.io/</link>
    <description>Recent content in Jepp Hu on Jepp Hu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Feb 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>iOS 原生分享</title>
      <link>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</guid>
      <description>&lt;p&gt;优点：使用简单，不用注册分享平台账号，不用导入的 SDK 包&lt;/p&gt;

&lt;p&gt;缺点：只能使用系统提供的固定样式，分享的类型受限，只能分享 text、url、image&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSArray *arr = @[result];
UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:arr applicationActivities:nil];
activityVC.completionWithItemsHandler = ^(UIActivityType  _Nullable activityType, BOOL completed, NSArray * _Nullable returnedItems, NSError * _Nullable activityError) {
    if (completed) {
        NSLog(@&amp;quot;share completed&amp;quot;);
    } else {
        NSLog(@&amp;quot;share failed&amp;quot;);
    }
};
[self presentViewController:activityVC animated:YES completion:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;arr 支持 UIActivity 类型，可以创建自定义的 Activity，同时分享 NSString，UIImage，NSURL&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git 配置多账户</title>
      <link>https://jepphu.github.io/2019/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E6%88%B7/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E6%88%B7/</guid>
      <description>

&lt;h3 id=&#34;1-为不同的账号生成对应的-key&#34;&gt;1. 为不同的账号生成对应的 key&lt;/h3&gt;

&lt;p&gt;检查是否有 .ssh 目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;cd ~/.ssh
#如果目录不存在，执行
ssh-keygen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成 github 和 bitbucket 的 key&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;cd ~/.ssh
ssh-keygen -t rsa -C &amp;quot;youremail@domain.com&amp;quot;
#执行命令后的第一次输入，输入一个用于区分的自定义名字,不要有空格，如：my_github_rsa，回车
第二次与第三次的输入是为了设定访问 key 的密码，可以直接回车跳过

ssh-keygen -t rsa -C &amp;quot;youremail@domain.com&amp;quot;
#同上自定义名字，如：my_bitbucket_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时在 .ssh 目录下至少会有以下5个文件，.pub 后缀的为公钥，另一个为秘钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;config           
my_bitbucket_rsa        my_github_rsa
my_bitbucket_rsa.pub    my_github_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-修改配置文件&#34;&gt;2. 修改配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;#进入 .ssh 目录，如果目录下没有 config 文件，那么创建
cd ~/.ssh
touch config

#添加以下内容
Host github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/my_github_rsa
Host bitbucket.org
    HostName bitbucket.org
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/my_bitbucket_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Host 字段只是别名，可以任意取，HostName 字段是真实的主机名&lt;/p&gt;

&lt;p&gt;如果 Host 字段任意取名，那么在进行 clone 等操作时要将 URL Host 替换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;#原本 
git clone git@github.com:xxx/xxx.git
#替换
git clone git@YourHost:xxx/xxx.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-向-github-和-bitbucket-添加秘钥&#34;&gt;3. 向 github 和 bitbucket 添加秘钥&lt;/h3&gt;

&lt;p&gt;将公钥添加在 github 或者 bitbucket 后台中，
以 github 为例：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;github 首页右上角头像下拉框 &amp;ndash;&amp;gt; settings &amp;ndash;&amp;gt; SSH and GPG keys&lt;/li&gt;
&lt;li&gt;title 部分，用于区分设备的名称&lt;/li&gt;
&lt;li&gt;key 部分，复制 my_github_rsa.pub 中的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;4-测试&#34;&gt;4. 测试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;ssh -T git@github.com
#输出 Hi XXX! You&#39;ve successfully authenticated, but GitHub does not provide shell access.

ssh -T git@bitbucket.org
#输出 You can use git or hg to connect to Bitbucket. Shell access is disabled

#测试过程中出现 The authenticity of host &#39;github.com (192.xxx.xxx.xxx)&#39; can&#39;t be established.
RSA key fingerprint is SHA256:...   
输入 yes，回车
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 Host 字段任意取名为 YourHost，测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;ssh -T git@YourHost 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>BaiduPCS Go</title>
      <link>https://jepphu.github.io/2019/baidupcs-go/</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/baidupcs-go/</guid>
      <description>

&lt;h3 id=&#34;baidupcs-go-https-github-com-gangzhuo-baidupcs&#34;&gt;&lt;a href=&#34;https://github.com/GangZhuo/BaiduPCS&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;BaiduPCS Go&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;用于从百度云盘下载文件的工具&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#登录百度帐号
BaiduPCS-Go login

#列出&amp;lt;文件或目录&amp;gt;
BaiduPCS-Go ls

#下载文件/目录
BaiduPCS-Go download &amp;lt;文件或目录&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#列出所有已登录的百度帐号
BaiduPCS-Go loglist

#获取当前帐号
BaiduPCS-Go who

#切换已登录的百度帐号
BaiduPCS-Go su &amp;lt;uid&amp;gt;

#退出当前登录的百度帐号
BaiduPCS-Go logout
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SFSafariViewController</title>
      <link>https://jepphu.github.io/2018/sfsafariviewcontroller/</link>
      <pubDate>Sun, 30 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/sfsafariviewcontroller/</guid>
      <description>&lt;p&gt;不用跳出 app，直接在 app 内打开隐私协议等网址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;lt;SafariServices/SafariServices.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;&amp;lt;SFSafariViewControllerDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (IBAction)action:(id)sender {
    NSURL *url = [NSURL URLWithString:@&amp;quot;https://jepphu.github.io/&amp;quot;];
    SFSafariViewController *safariVC = [[SFSafariViewController alloc] initWithURL:url];
    safariVC.delegate = self;
//    self.navigationController.navigationBarHidden = YES;
//    [self.navigationController pushViewController:safariVC animated:YES];
    [self presentViewController:safariVC animated:YES completion:nil];
}

// 加载完成
- (void)safariViewController:(SFSafariViewController *)controller didCompleteInitialLoad:(BOOL)didLoadSuccessfully {

}

// 按钮 Done
- (void)safariViewControllerDidFinish:(SFSafariViewController *)controller {

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UINavigationBar</title>
      <link>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</guid>
      <description>

&lt;h3 id=&#34;uinavgationbar-设置颜色&#34;&gt;UINavgationBar 设置颜色&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UINavigationController *nav = self.navigationController;
nav.navigationBar.tintColor = [UIColor whiteColor];
nav.navigationBar.barTintColor = [UIColor colorWithRed:28/255.0 green:152/255.0 blue:225/255.0 alpha:1.0];
nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor whiteColor]};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时会觉得 navigationbar 颜色很浅，因为这是半透明状态&lt;/p&gt;

&lt;p&gt;默认 &lt;code&gt;navigationbar.translucent = YES&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;改为 &lt;code&gt;navigationbar.translucent = NO&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;颜色问题解决，但是子控制器视图整体下移，加上下面这句&lt;/p&gt;

&lt;p&gt;&lt;code&gt;self.extendedLayoutIncludesOpaqueBars = YES;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者在 storyboard 中 viewController 属性勾选 Under Opaque Bars&lt;/p&gt;

&lt;p&gt;如果有特殊需求，尝试使用下面的方法&lt;/p&gt;

&lt;h3 id=&#34;透明化和显示-uinavigationbar-以及-uinavigationbar-底部的线&#34;&gt;透明化和显示 UINavigationBar 以及 UINavigationBar 底部的线&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;方法1：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (UIImageView *)navigationBarLineUnder:(UIView *)navigationBar {
    if ([navigationBar isKindOfClass:[UIImageView class]] &amp;amp;&amp;amp; navigationBar.bounds.size.height &amp;lt;= 1.0) {
        return (UIImageView *)navigationBar;
    }
    for (UIView *subview in navigationBar.subviews) {
        UIImageView *imageView= [self navigationBarLineUnder:subview];
        if (imageView) {
            return imageView;
            }
    }
    return nil;
}

//隐藏
[self navigationBarLineUnder:self.navigationController.navigationBar].hidden = YES;

//显示
[self navigationBarLineUnder:self.navigationController.navigationBar].hidden = NO;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;方法2：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;//隐藏
[self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc] init] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[[UIImage alloc] init]];

//显示
[self.navigationController.navigationBar setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:nil];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>present 一个 navigation</title>
      <link>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</guid>
      <description>&lt;p&gt;在 present 页面之后的页面需要使用 navigation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:logInVC];
nav.navigationBar.tintColor = [UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0];
nav.navigationBar.barTintColor = [UIColor whiteColor];
nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0]};
[self presentViewController:nav animated:NO completion:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为 present 出来的 navigation 添加返回按钮&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;if (self.navigationController.navigationItem.hidesBackButton) {
    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&amp;quot;Back&amp;quot; style:UIBarButtonItemStylePlain target:self action:@selector(dismissVC)];
}

- (void)dismissVC {
    [self dismissViewControllerAnimated:YES completion:nil];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>绘制 image</title>
      <link>https://jepphu.github.io/2018/%E7%BB%98%E5%88%B6image/</link>
      <pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E7%BB%98%E5%88%B6image/</guid>
      <description>

&lt;h3 id=&#34;绘制空白的-image&#34;&gt;绘制空白的 image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIColor *color = [UIColor whiteColor];
CGRect rect = CGRectMake(0, 0, 200, 200);
UIGraphicsBeginImageContext(rect.size);
CGContextRef context = UIGraphicsGetCurrentContext();
CGContextSetFillColorWithColor(context, color.CGColor);
CGContextFillRect(context, rect);
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>App 发送邮件</title>
      <link>https://jepphu.github.io/2018/app%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/app%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</guid>
      <description>

&lt;h3 id=&#34;ios-app-发送邮件&#34;&gt;iOS App 发送邮件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;lt;MessageUI/MessageUI.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;&amp;lt;MFMailComposeViewControllerDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[self sendEmail:@&amp;quot;jepp.hu@mail.com&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)sendEmail:(NSString *)email {
    if ([MFMailComposeViewController canSendMail]) {
//        [self.navigationController presentViewController:[self configuredMailComposeViewControllerWithEmail:email] animated:YES completion:nil];
        [self presentViewController:[self configuredMailComposeViewControllerWithEmail:email] animated:YES completion:nil];
    } else {
        UIAlertController *sendMailErrorAlert = [UIAlertController alertControllerWithTitle:@&amp;quot;Can not send&amp;quot; message:@&amp;quot;Please set your email&amp;quot; preferredStyle:UIAlertControllerStyleAlert];
        [sendMailErrorAlert addAction:[UIAlertAction actionWithTitle:@&amp;quot;OK&amp;quot; style:UIAlertActionStyleDefault handler:nil]];
//        [self.navigationController presentViewController:sendMailErrorAlert animated:YES completion:nil];
        [self presentViewController:sendMailErrorAlert animated:YES completion:nil];
    }
}

- (MFMailComposeViewController *)configuredMailComposeViewControllerWithEmail:(NSString *)email {
    MFMailComposeViewController *mfVC = [[MFMailComposeViewController alloc] init];
    mfVC.mailComposeDelegate = self;
    // 地址
    [mfVC setToRecipients:@[email]];
    // 主题
    [mfVC setSubject:@&amp;quot;&amp;quot;];
    // 内容
    [mfVC setMessageBody:@&amp;quot;&amp;quot; isHTML:NO];
    return mfVC;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// MFMailComposeViewControllerDelegate
- (void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error {
    if (result == MFMailComposeResultFailed) {
        
    } else if (result == MFMailComposeResultSent) {
        
    }
    
    //关闭邮件发送窗口
    [controller dismissViewControllerAnimated:YES completion:nil];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;osx-app-发送邮件&#34;&gt;OSX App 发送邮件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[self sendEmail:@&amp;quot;jepp.hu@mail.com&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)sendEmail:(NSString *)email {
    NSString *recipients = [NSString stringWithFormat:@&amp;quot;mailto:%@?subject=%@&amp;quot;,eamil,@&amp;quot;subject&amp;quot;];
    NSString *body = [NSString stringWithFormat:@&amp;quot;&amp;amp;body=%@ I have something to say about %@ %@:\n&amp;quot;, @&amp;quot;body&amp;quot;, @&amp;quot;appName&amp;quot;, @&amp;quot;version&amp;quot;];
    NSString *email = [NSString stringWithFormat:@&amp;quot;%@%@&amp;quot;, recipients, body];
    email = [email stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:email]];
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS 约束布局与动画</title>
      <link>https://jepphu.github.io/2018/ios%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Sun, 10 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/ios%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8A%A8%E7%94%BB/</guid>
      <description>&lt;p&gt;在控件被添加了约束的情况下，修改 frame 是无法实现的动画的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;修改约束的值&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;layoutIfNeeded&lt;/code&gt;，要注意调用时机&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;self.viewHeight.constant = 0;

[UIView animateWithDuration:0.25 animations:^{
    [self.view layoutIfNeeded];
}];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UIButton 设置背景图片</title>
      <link>https://jepphu.github.io/2018/uibutton%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uibutton%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</guid>
      <description>&lt;p&gt;背景图自适应尺寸拉伸&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[button setBackgroundImage:image forState:UIControlStateNormal];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;背景图不拉伸&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[button setImage:image forState:UIControlStateNormal];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关闭按钮点击时高亮的效果, 但是高亮的状态还在,只是效果没了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;button.adjustsImageWhenDisabled = NO;&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UIImage 渲染</title>
      <link>https://jepphu.github.io/2018/uiimage%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiimage%E6%B8%B2%E6%9F%93/</guid>
      <description>

&lt;p&gt;UIImage 有个 UIImageRenderingMode 属性，默认为 UIImageRenderingModeAutomatic&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (UIImage *)imageWithRenderingMode:(UIImageRenderingMode)renderingMode;

typedef NS_ENUM(NSInteger, UIImageRenderingMode) {
    UIImageRenderingModeAutomatic,          // 根据图片所处的绘图上下文自动调整渲染模式
    UIImageRenderingModeAlwaysOriginal,     // 始终绘制图片原始状态，不使用 Tint Color 渲染
    UIImageRenderingModeAlwaysTemplate,     // 始终根据环境的 Tint Color 渲染图片，忽略图片的本身的颜色信息
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;这个属性会导致一个常见的问题-uitabbaritem-上的-image-颜色与设置的原图不同&#34;&gt;这个属性会导致一个常见的问题：UITabBarItem 上的 image 颜色与设置的原图不同&lt;/h3&gt;

&lt;p&gt;让 image 保持原图不被渲染有两种方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;代码设置，这个只是局部的修改&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIImage *leftImage = [[UIImage imageNamed:@&amp;quot;icon_s&amp;quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
self.navigationItem.leftBarButtonItem.image = leftImage;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;进入 Assets.xcassets，找到图片资源，在属性栏中有 Render As 属性，选中 Original Image&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在整个工程中，使用到这个 image 都不会被环境的 Tint Color 渲染&lt;/p&gt;

&lt;h3 id=&#34;可以利用这个属性来将-image-渲染成想要的颜色&#34;&gt;可以利用这个属性来将 image 渲染成想要的颜色&lt;/h3&gt;

&lt;p&gt;设置环境的 Tint Color，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIImage *img = [[UIImage imageNamed:@&amp;quot;icon_shut_down&amp;quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
btn.tintColor = [UIColor whiteColor];
[btn setImage:img forState:UIControlStateNormal];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UIView 事件拦截</title>
      <link>https://jepphu.github.io/2018/uiview%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiview%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/</guid>
      <description>

&lt;h3 id=&#34;hittest-方法会递归来寻找第一响应者&#34;&gt;hitTest: 方法会递归来寻找第一响应者&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;判断 point 是否在自身范围内，不在则返回 nil，在则执行第 2 步&lt;/li&gt;
&lt;li&gt;检查 subViews，判断 point 是否在 subView 范围内，在则返回 subView（此时 subView 成为第一响应者，subView会执行 hitTest:）&lt;/li&gt;
&lt;li&gt;如果所有 subViews 都不包含 point，只有自身包含（第1步）那就返回 self（自身成为第一响应者）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;subviews-上的事件全部由父-view-来实现&#34;&gt;subViews 上的事件全部由父 View 来实现&lt;/h3&gt;

&lt;p&gt;重写父级 View 的 hitTest 方法，返回 self，自身成为第一响应者&lt;/p&gt;

&lt;p&gt;subViews 的 touch 相关方法不会响应&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    // 直接返回 self 这样自身就成为了第一响应者 subViews 不能够接受到响应事件
    if (CGRectContainsPoint(self.bounds, point)) {
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;允许部分-subviews-响应事件&#34;&gt;允许部分 subViews 响应事件&lt;/h3&gt;

&lt;p&gt;重写父级 View 的 hitTest 方法，返回某个 subView，subView 成为第一响应者&lt;/p&gt;

&lt;p&gt;其余未返回的子 View 的事件将被拦截&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (CGRectContainsPoint(self.slider.frame, point)) {
        return self.slider;
    } else if (CGRectContainsPoint(self.btn.frame, point)) {
        return self.resetBtn;
    }
    return self.scrollView;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UIView 子视图坐标转换</title>
      <link>https://jepphu.github.io/2018/uiview%E5%AD%90%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiview%E5%AD%90%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;p&gt;ViewA, ViewB, ViewC&lt;/p&gt;

&lt;p&gt;ViewA 是 ViewB 的父视图，ViewB 是 ViewC 的父视图&lt;/p&gt;

&lt;p&gt;ViewC 此时的 frame 是相对于 ViewB 的&lt;/p&gt;

&lt;p&gt;如果需求为获取 ViewC 此时相对于 ViewA 的 frame&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;
- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;

CGRect frame = [ViewB convertRect:ViewC.frame toView:ViewA];
//或
CGRect frame = [ViewA convertRect:ViewC.frame fromView:ViewB];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>收回键盘</title>
      <link>https://jepphu.github.io/2018/%E6%94%B6%E5%9B%9E%E9%94%AE%E7%9B%98/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E6%94%B6%E5%9B%9E%E9%94%AE%E7%9B%98/</guid>
      <description>&lt;p&gt;收回键盘主要调用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[self.view endEditing:YES] 
//或 
[self.emailTextField resignFirstResponder]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ViewController :&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    [self.view endEditing:YES];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;TableViewController :&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    [self.view endEditing:YES];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// 弹出键盘&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[self.textField becomeFirstResponder]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UITableViewCell 改变选时中颜色</title>
      <link>https://jepphu.github.io/2018/uitableviewcell%E6%94%B9%E5%8F%98%E9%80%89%E6%97%B6%E4%B8%AD%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uitableviewcell%E6%94%B9%E5%8F%98%E9%80%89%E6%97%B6%E4%B8%AD%E9%A2%9C%E8%89%B2/</guid>
      <description>&lt;p&gt;TableViewCell 有一个 selectedBackgroundView 属性&lt;/p&gt;

&lt;p&gt;创建一个 View 设为 selectedBackgroundView，就可以改变选中状态下的 cell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIView *view = [[UIView alloc] initWithFrame:self.bounds];
view.backgroundColor = [UIColor whiteColor];
self.selectedBackgroundView = view;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>