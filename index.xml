<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jepp Hu on Jepp Hu</title>
    <link>https://jepphu.github.io/</link>
    <description>Recent content in Jepp Hu on Jepp Hu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 Mar 2019 17:19:34 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NSJSONSerialization</title>
      <link>https://jepphu.github.io/2019/nsjsonserialization/</link>
      <pubDate>Fri, 15 Mar 2019 17:19:34 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsjsonserialization/</guid>
      <description>

&lt;h3 id=&#34;json-序列化&#34;&gt;JSON 序列化&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// 输出的 json 字符串就是一整行
NSJSONWritingSortedKeys
// 是将生成的 json 数据格式化输出，这样可读性高，不设置则输出的 json 字符串就是一整行
NSJSONWritingPrettyPrinted
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;+ (NSString *)jsonStringEncodedWithDic:(NSDictionary *)dic {
    if ([NSJSONSerialization isValidJSONObject:dic]) {
        NSError *error;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:0 error:&amp;amp;error];
        NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
        return json;
    }
    return nil;
}

+ (NSString *)jsonPrettyStringEncodedWithDic:(NSDictionary *)dic {
    if ([NSJSONSerialization isValidJSONObject:dic]) {
        NSError *error;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;amp;error];
        NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
        return json;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;json-反序列化&#34;&gt;JSON 反序列化&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// 返回的对象是不可变的，NSDictionary 或 NSArray
kNilOptions
// 返回可变容器，NSMutableDictionary 或 NSMutableArray，返回的是数组字典嵌套的情况，每一层都是可变的
NSJSONReadingMutableContainers
// 返回的 JSON 对象中字符串的值类型为 NSMutableString
NSJSONReadingMutableLeaves
// 允许JSON字符串最外层既不是 NSArray 也不是 NSDictionary，但必须是有效的JSON Fragment
NSJSONReadingAllowFragments     
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;+ (id)jsonValueDecodedWithStr:(NSString *)str {
    NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
    NSError *error;
    id value = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;amp;error];
    if (error) {
        NSLog(@&amp;quot;%s error:%@&amp;quot;, __func__, error);
    }
    return value;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>NSString 语音阅读</title>
      <link>https://jepphu.github.io/2019/nsstring%E8%AF%AD%E9%9F%B3%E9%98%85%E8%AF%BB/</link>
      <pubDate>Fri, 15 Mar 2019 17:15:22 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsstring%E8%AF%AD%E9%9F%B3%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;lt;AVFoundation/AVFoundation.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;AVSpeechSynthesizer *synthesize = [[AVSpeechSynthesizer alloc]init];
AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc]initWithString:self.textView.text];
[synthesize speakUtterance:utterance];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>NSString 复制到剪切板</title>
      <link>https://jepphu.github.io/2019/nsstring%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</link>
      <pubDate>Fri, 15 Mar 2019 17:11:42 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsstring%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
pasteboard.string = self.textView.text;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>NSString 与 UTF-8</title>
      <link>https://jepphu.github.io/2019/nsstring%E4%B8%8Eutf-8/</link>
      <pubDate>Fri, 15 Mar 2019 17:02:35 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/nsstring%E4%B8%8Eutf-8/</guid>
      <description>

&lt;h3 id=&#34;nsstring-转-uft-8-编码&#34;&gt;NSString 转 UFT-8 编码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSString *text = @&amp;quot;你好, 世界&amp;quot;;
NSCharacterSet *charSet = [[NSCharacterSet characterSetWithCharactersInString:text] invertedSet];
text = [text stringByAddingPercentEncodingWithAllowedCharacters:charSet];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;uft-8-转-nsstring-解码&#34;&gt;UFT-8 转 NSString 解码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSString *text = [text stringByRemovingPercentEncoding];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>不使用 storyBoard</title>
      <link>https://jepphu.github.io/2019/%E4%B8%8D%E4%BD%BF%E7%94%A8storyboard/</link>
      <pubDate>Fri, 15 Mar 2019 15:56:28 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/%E4%B8%8D%E4%BD%BF%E7%94%A8storyboard/</guid>
      <description>

&lt;h3 id=&#34;纯代码的方式开始搭建界面&#34;&gt;纯代码的方式开始搭建界面&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
    UIViewController *redView = [[UIViewController alloc] init];
    redView.view.backgroundColor = [UIColor redColor];

    //1. 直接以 UIViewController 作为 window 的根控制器
//    self.window.rootViewController = redView;
//    [self.window makeKeyAndVisible];

    //2. 以 UINavigationController 作为 window 的根控制器(44px)
//    UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:redView];
//    nav.view.backgroundColor = [UIColor grayColor];
//    self.window.rootViewController = nav;
//    [self.window makeKeyAndVisible];

    //3. 以 UITabBarController 作为 window 的根控制器
    UITabBarController *tabBarController = [[UITabBarController alloc] init];
    UIViewController *v1 = [[UIViewController alloc] init];
    v1.view.backgroundColor = [UIColor redColor];
    v1.tabBarItem.badgeValue = @&amp;quot;v1&amp;quot;;
    UIViewController *v2 = [[UIViewController alloc] init];
    v2.view.backgroundColor = [UIColor greenColor];
    v2.tabBarItem.badgeValue = @&amp;quot;666&amp;quot;;
    [tabBarController addChildViewController:v1];
    [tabBarController addChildViewController:v2];

    self.window.rootViewController = tabBarController;
    [self.window makeKeyAndVisible];
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UIGestureRecognizer</title>
      <link>https://jepphu.github.io/2019/uigesturerecognizer/</link>
      <pubDate>Fri, 15 Mar 2019 15:45:29 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/uigesturerecognizer/</guid>
      <description>

&lt;h3 id=&#34;点击&#34;&gt;点击&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// 创建点击手势对象
UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];
// 几个手指
tap.numberOfTouchesRequired = 2;
// 点击几次
tap.numberOfTapsRequired = 2;
// 给 View 添加一个手势
[self.imageView addGestureRecognizer:tap];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;长按&#34;&gt;长按&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];
// 长按时间
longPress.minimumPressDuration = 0.5;
// 在长按时移动允许的误差范围, 超过范围 误差失效
longPress.allowableMovement = 50;
[self.imageView addGestureRecognizer:longPress];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)longPress:(UILongPressGestureRecognizer *)sender {
    // 默认长按移动时会一直执行, 放开时也会执行, 加个判断, 只执行一次
    if (sender.state == UIGestureRecognizerStateBegan) {
        NSLog(@&amp;quot;%s&amp;quot;, __FUNCTION__);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;清扫&#34;&gt;清扫&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UISwipeGestureRecognizer *swipe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];
// 控制识别的手势方向, 默认识别从左往右, 此处改为从右往左
swipe.direction = UISwipeGestureRecognizerDirectionLeft;
[self.imageView addGestureRecognizer:swipe];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;旋转&#34;&gt;旋转&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIRotationGestureRecognizer *rotation = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotation:)];
[self.imageView addGestureRecognizer:rotation];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)rotation:(UIRotationGestureRecognizer *)sender {
    NSLog(@&amp;quot;%s--%f&amp;quot;, __FUNCTION__, sender.rotation);
    self.imageView.transform = CGAffineTransformRotate(self.imageView.transform, sender.rotation);
    // 恢复到初始状态, 避免叠加旋转
    sender.rotation = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;捏合&#34;&gt;捏合&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinch:)];
[self.imageView addGestureRecognizer:pinch];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)pinch:(UIPinchGestureRecognizer *)sender {
    NSLog(@&amp;quot;%s--%f&amp;quot;, __FUNCTION__, sender.scale);
    self.imageView.transform = CGAffineTransformScale(self.imageView.transform, sender.scale, sender.scale);
    // 恢复到初始状态, 避免叠加
    sender.scale = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;拖拽&#34;&gt;拖拽&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];
[self.imageView addGestureRecognizer:pan];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)pan:(UIPanGestureRecognizer *)sender {
    CGPoint p = [sender translationInView:sender.view];
    self.imageView.transform = CGAffineTransformTranslate(self.imageView.transform, p.x, p.y);
    NSLog(@&amp;quot;%s--%@&amp;quot;, __FUNCTION__, NSStringFromCGPoint(p));
    // 恢复到初始状态, 避免叠加
    [sender setTranslation:CGPointZero inView:sender.view];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;手势冲突&#34;&gt;手势冲突&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// &amp;lt;UIGestureRecognizerDelegate&amp;gt;
// 旋转和拖放手势冲突, 通过代理解决, 可以同时使用
rotation.delegate = self;
pinch.delegate = self;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>信号量实现 NSURLSession 的同步请求</title>
      <link>https://jepphu.github.io/2019/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0nsurlsession%E7%9A%84%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Thu, 07 Mar 2019 18:46:19 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0nsurlsession%E7%9A%84%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82/</guid>
      <description>&lt;p&gt;NSURLSession 只有异步请求&lt;/p&gt;

&lt;p&gt;通过信号量来实现同步&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *url = [NSURL URLWithString:@&amp;quot;https://jepphu.github.io/&amp;quot;];
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
[request setHTTPMethod:@&amp;quot;GET&amp;quot;];

NSLog(@&amp;quot;1 -- %@&amp;quot;,[NSThread currentThread]);
__block NSURLResponse *resultResponse;
__block NSError *resultError;
__block NSData *resultData;

//创建信号量
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
NSURLSessionTask *task = [[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
    resultResponse = response;
    resultError = error;
    resultData = data;
    NSLog(@&amp;quot;2 -- %@&amp;quot;,[NSThread currentThread]);
    //发送信号
    dispatch_semaphore_signal(semaphore);
}];

[task resume];
//等待
dispatch_semaphore_wait(semaphore,DISPATCH_TIME_FOREVER);  
NSLog(@&amp;quot;3 -- %@&amp;quot;,[NSThread currentThread]);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UIImageView 的 contentMode 属性</title>
      <link>https://jepphu.github.io/2019/uiimageview/</link>
      <pubDate>Tue, 05 Mar 2019 20:11:26 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2019/uiimageview/</guid>
      <description>

&lt;h3 id=&#34;contentmode&#34;&gt;contentMode&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIViewContentModeScaleToFill,       // 默认，对图片进行拉伸处理，不按比例充满 bounds
UIViewContentModeScaleAspectFit,    // 按原图比例进行拉伸，图片完全展示在 bounds 中，会留白，不会裁剪
UIViewContentModeScaleAspectFill,   // 按原图比例填充，使图片展示在bouns中，可能会被裁剪

UIViewContentModeRedraw,            // 原图重新绘制在 bounds 内，充满 (calls -setNeedsDisplay)
UIViewContentModeCenter,            // 图片显示在 imageview 的正中间，原图大小，可能会被裁剪

UIViewContentModeTop,               // 图片从 imageview 的上部开始显示，原图大小，可能会被裁剪
UIViewContentModeBottom,            // 图片从 imageview 的下部开始显示，原图大小，可能会被裁剪
UIViewContentModeLeft,              // 图片从 imageview 的左部开始显示，原图大小，可能会被裁剪
UIViewContentModeRight,             // 图片从 imageview 的右部开始显示，原图大小，可能会被裁剪
UIViewContentModeTopLeft,           // 图片从 imageview 的左上部开始显示，原图大小，可能会被裁剪
UIViewContentModeTopRight,          // 图片从 imageview 的右上部开始显示，原图大小，可能会被裁剪
UIViewContentModeBottomLeft,        // 图片从 imageview 的左下部开始显示，原图大小，可能会被裁剪
UIViewContentModeBottomRight,       // 图片从 imageview 的右下部开始显示，原图大小，可能会被裁剪
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS 原生分享</title>
      <link>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</guid>
      <description>&lt;p&gt;优点：使用简单，不用注册分享平台账号，不用导入的 SDK 包&lt;/p&gt;

&lt;p&gt;缺点：只能使用系统提供的固定样式，分享的类型受限，只能分享 text、url、image&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSArray *arr = @[result];
UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:arr applicationActivities:nil];
activityVC.completionWithItemsHandler = ^(UIActivityType  _Nullable activityType, BOOL completed, NSArray * _Nullable returnedItems, NSError * _Nullable activityError) {
    if (completed) {
        NSLog(@&amp;quot;share completed&amp;quot;);
    } else {
        NSLog(@&amp;quot;share failed&amp;quot;);
    }
};
[self presentViewController:activityVC animated:YES completion:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;arr 支持 UIActivity 类型，可以创建自定义的 Activity，同时分享 NSString，UIImage，NSURL&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git 配置多账户</title>
      <link>https://jepphu.github.io/2019/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E6%88%B7/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E6%88%B7/</guid>
      <description>

&lt;h3 id=&#34;1-为不同的账号生成对应的-key&#34;&gt;1. 为不同的账号生成对应的 key&lt;/h3&gt;

&lt;p&gt;检查是否有 .ssh 目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;cd ~/.ssh
#如果目录不存在，执行
ssh-keygen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成 github 和 bitbucket 的 key&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;cd ~/.ssh
ssh-keygen -t rsa -C &amp;quot;youremail@domain.com&amp;quot;
#执行命令后的第一次输入，输入一个用于区分的自定义名字,不要有空格，如：my_github_rsa，回车
第二次与第三次的输入是为了设定访问 key 的密码，可以直接回车跳过

ssh-keygen -t rsa -C &amp;quot;youremail@domain.com&amp;quot;
#同上自定义名字，如：my_bitbucket_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时在 .ssh 目录下至少会有以下5个文件，.pub 后缀的为公钥，另一个为秘钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;config           
my_bitbucket_rsa        my_github_rsa
my_bitbucket_rsa.pub    my_github_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-修改配置文件&#34;&gt;2. 修改配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;#进入 .ssh 目录，如果目录下没有 config 文件，那么创建
cd ~/.ssh
touch config

#添加以下内容
Host github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/my_github_rsa
Host bitbucket.org
    HostName bitbucket.org
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/my_bitbucket_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Host 字段只是别名，可以任意取，HostName 字段是真实的主机名&lt;/p&gt;

&lt;p&gt;如果 Host 字段任意取名，那么在进行 clone 等操作时要将 URL Host 替换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;#原本 
git clone git@github.com:xxx/xxx.git
#替换
git clone git@YourHost:xxx/xxx.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-向-github-和-bitbucket-添加秘钥&#34;&gt;3. 向 github 和 bitbucket 添加秘钥&lt;/h3&gt;

&lt;p&gt;将公钥添加在 github 或者 bitbucket 后台中，
以 github 为例：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;github 首页右上角头像下拉框 &amp;ndash;&amp;gt; settings &amp;ndash;&amp;gt; SSH and GPG keys&lt;/li&gt;
&lt;li&gt;title 部分，用于区分设备的名称&lt;/li&gt;
&lt;li&gt;key 部分，复制 my_github_rsa.pub 中的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;4-测试&#34;&gt;4. 测试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;ssh -T git@github.com
#输出 Hi XXX! You&#39;ve successfully authenticated, but GitHub does not provide shell access.

ssh -T git@bitbucket.org
#输出 You can use git or hg to connect to Bitbucket. Shell access is disabled

#测试过程中出现 The authenticity of host &#39;github.com (192.xxx.xxx.xxx)&#39; can&#39;t be established.
RSA key fingerprint is SHA256:...   
输入 yes，回车
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 Host 字段任意取名为 YourHost，测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;ssh -T git@YourHost 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>BaiduPCS Go</title>
      <link>https://jepphu.github.io/2019/baidupcs-go/</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/baidupcs-go/</guid>
      <description>

&lt;h3 id=&#34;baidupcs-go-https-github-com-gangzhuo-baidupcs&#34;&gt;&lt;a href=&#34;https://github.com/GangZhuo/BaiduPCS&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;BaiduPCS Go&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;用于从百度云盘下载文件的工具&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#登录百度帐号
BaiduPCS-Go login

#列出&amp;lt;文件或目录&amp;gt;
BaiduPCS-Go ls

#下载文件/目录
BaiduPCS-Go download &amp;lt;文件或目录&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#列出所有已登录的百度帐号
BaiduPCS-Go loglist

#获取当前帐号
BaiduPCS-Go who

#切换已登录的百度帐号
BaiduPCS-Go su &amp;lt;uid&amp;gt;

#退出当前登录的百度帐号
BaiduPCS-Go logout
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SFSafariViewController</title>
      <link>https://jepphu.github.io/2018/sfsafariviewcontroller/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/sfsafariviewcontroller/</guid>
      <description>&lt;p&gt;不用跳出 app，直接在 app 内打开隐私协议等网址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;lt;SafariServices/SafariServices.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;&amp;lt;SFSafariViewControllerDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (IBAction)action:(id)sender {
    NSURL *url = [NSURL URLWithString:@&amp;quot;https://jepphu.github.io/&amp;quot;];
    SFSafariViewController *safariVC = [[SFSafariViewController alloc] initWithURL:url];
    safariVC.delegate = self;
//    self.navigationController.navigationBarHidden = YES;
//    [self.navigationController pushViewController:safariVC animated:YES];
    [self presentViewController:safariVC animated:YES completion:nil];
}

// 加载完成
- (void)safariViewController:(SFSafariViewController *)controller didCompleteInitialLoad:(BOOL)didLoadSuccessfully {

}

// 按钮 Done
- (void)safariViewControllerDidFinish:(SFSafariViewController *)controller {

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网络基础</title>
      <link>https://jepphu.github.io/2018/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 25 Sep 2018 17:00:00 +0800</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
      <description>

&lt;h3 id=&#34;网络基本概念&#34;&gt;网络基本概念&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;客户端（前端）：应用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务器（后端）：为客户端提供服务、数据和资源的机器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求：客户端向服务器索取数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;响应：服务器对客户端的请求作出反应，一般是服务器从数据库获得数据，然后返回给客户端&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C/S : Client/Server&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;B/S : Browser/Server&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;服务器&#34;&gt;服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内网服务器：局域网内部的服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;外网服务器：所有用户通过互联网能访问到的服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地测试服务器：简化开发过程，在本地搭建一个服务器，用于测试&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;url&#34;&gt;URL&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;URL : Uniform Resource Locatora，统一资源定位符&lt;/p&gt;

&lt;p&gt;网络中每一个资源都对应唯一的地址-URL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;URL 的基本格式：协议://主机地址:端口号/路径&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;协议：不同的协议代表不同的资源获取方式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主机地址：主机的唯一标示（IP地址，域名）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;路径：资源在主机中的具体位置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;URL 常见协议&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;http ：HyperText Transfer Protocol，超文本传输协议&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ftp ：文件传输协议&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mailto ：电子邮件协议&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;file ：本地文件传输协议&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tel ：电话&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sms ：短信&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般输入网址不写协议、端口号、路径会默认 http 协议，80 端口，index.html 路径&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;http-协议简介&#34;&gt;http 协议简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HyperText Transfer Protocol，超文本传输协议，提供超文本（文字，图片，声音，视频等）传输服务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端/浏览器和服务器通讯时候遵守的约定&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;互联网使用的最多的协议（使用简单，但并不算快）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dns-服务器&#34;&gt;DNS 服务器&lt;/h3&gt;

&lt;p&gt;域名解析服务器：将域名转换为 IP 地址&lt;/p&gt;

&lt;p&gt;DNS 服务器以类似字典的存储方式，将域名和 IP 对应存储，查找时从下级服务器开始往上级查询，最终查到 root 服务器，直到找到对应 IP 为止。解析一次以后，就会下级服务器被记录下来。&lt;/p&gt;

&lt;h3 id=&#34;ip-简介&#34;&gt;IP 简介&lt;/h3&gt;

&lt;p&gt;两个计算机要通讯，必须知道 IP 地址和端口号&lt;/p&gt;

&lt;p&gt;IP 地址是一个 32 位的二进制数字，通常被分割为 8 位的二进制数，通常用点分 10 进制来表示&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;198.168.1.1 一般为路由器的地址&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;127.0.0.1 回环地址（本机地址）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;255.255.255.255 广播地址&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;端口号&#34;&gt;端口号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;端口号用于标示进程的逻辑地址&lt;/p&gt;

&lt;p&gt;一台服务器上可能运行多个软件，提供多个服务，为了让不同的客户端准确的请求到想要的服务，就让不同的服务有不同的端口号&lt;/p&gt;

&lt;p&gt;IP 确定是哪个计算机，端口号则确定将数据传给哪个服务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;端口号取值范围： 0 ～ 65535&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;端口的分类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;公认端口 （Well Known Ports）：也称之为常用端口，从 0 到 1023，它们紧密绑定于一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象。比如：http 默认 80，ftp 默认 21&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注册端口 （Registered Ports）：端口号从 1024 到 49151，是操作系统分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;动态/私有端口 （Dynamic / Private Ports）：端口号从 49152 到 65535 。之所以成为动态端口，是因为它一般不固定分配某种服务，而是动态分配&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UINavigationBar</title>
      <link>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</guid>
      <description>

&lt;h3 id=&#34;uinavgationbar-设置颜色&#34;&gt;UINavgationBar 设置颜色&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UINavigationController *nav = self.navigationController;
nav.navigationBar.tintColor = [UIColor whiteColor];
nav.navigationBar.barTintColor = [UIColor colorWithRed:28/255.0 green:152/255.0 blue:225/255.0 alpha:1.0];
nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor whiteColor]};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时会觉得 navigationbar 颜色很浅，因为这是半透明状态&lt;/p&gt;

&lt;p&gt;默认 &lt;code&gt;navigationbar.translucent = YES&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;改为 &lt;code&gt;navigationbar.translucent = NO&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;颜色问题解决，但是子控制器视图整体下移，加上下面这句&lt;/p&gt;

&lt;p&gt;&lt;code&gt;self.extendedLayoutIncludesOpaqueBars = YES;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者在 storyboard 中 viewController 属性勾选 Under Opaque Bars&lt;/p&gt;

&lt;p&gt;如果有特殊需求，尝试使用下面的方法&lt;/p&gt;

&lt;h3 id=&#34;透明化和显示-uinavigationbar-以及-uinavigationbar-底部的线&#34;&gt;透明化和显示 UINavigationBar 以及 UINavigationBar 底部的线&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;方法1：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (UIImageView *)navigationBarLineUnder:(UIView *)navigationBar {
    if ([navigationBar isKindOfClass:[UIImageView class]] &amp;amp;&amp;amp; navigationBar.bounds.size.height &amp;lt;= 1.0) {
        return (UIImageView *)navigationBar;
    }
    for (UIView *subview in navigationBar.subviews) {
        UIImageView *imageView= [self navigationBarLineUnder:subview];
        if (imageView) {
            return imageView;
            }
    }
    return nil;
}

//隐藏
[self navigationBarLineUnder:self.navigationController.navigationBar].hidden = YES;

//显示
[self navigationBarLineUnder:self.navigationController.navigationBar].hidden = NO;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;方法2：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;//隐藏
[self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc] init] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[[UIImage alloc] init]];

//显示
[self.navigationController.navigationBar setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:nil];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>present 一个 navigation</title>
      <link>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</guid>
      <description>&lt;p&gt;在 present 页面之后的页面需要使用 navigation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:logInVC];
nav.navigationBar.tintColor = [UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0];
nav.navigationBar.barTintColor = [UIColor whiteColor];
nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0]};
[self presentViewController:nav animated:NO completion:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为 present 出来的 navigation 添加返回按钮&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;if (self.navigationController.navigationItem.hidesBackButton) {
    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&amp;quot;Back&amp;quot; style:UIBarButtonItemStylePlain target:self action:@selector(dismissVC)];
}

- (void)dismissVC {
    [self dismissViewControllerAnimated:YES completion:nil];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>