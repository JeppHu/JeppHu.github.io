<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>UIKit on Jepp Hu</title>
    <link>https://jepphu.github.io/categories/uikit/</link>
    <description>Recent content in UIKit on Jepp Hu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jepphu.github.io/categories/uikit/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS 原生分享</title>
      <link>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/ios%E5%8E%9F%E7%94%9F%E5%88%86%E4%BA%AB/</guid>
      <description>优点：使用简单，不用注册分享平台账号，不用导入的 SDK 包
缺点：只能使用系统提供的固定样式，分享的类型受限，只能分享 text、url、image
NSArray *arr = @[result]; UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:arr applicationActivities:nil]; activityVC.completionWithItemsHandler = ^(UIActivityType _Nullable activityType, BOOL completed, NSArray * _Nullable returnedItems, NSError * _Nullable activityError) { if (completed) { NSLog(@&amp;quot;share completed&amp;quot;); } else { NSLog(@&amp;quot;share failed&amp;quot;); } }; [self presentViewController:activityVC animated:YES completion:nil];  arr 支持 UIActivity 类型，可以创建自定义的 Activity，同时分享 NSString，UIImage，NSURL</description>
    </item>
    
    <item>
      <title>iOS 约束布局与动画</title>
      <link>https://jepphu.github.io/2019/ios%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2019/ios%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8A%A8%E7%94%BB/</guid>
      <description>在控件被添加了约束的情况下，修改 frame 是无法实现的动画的
 修改约束的值 调用 layoutIfNeeded，要注意调用时机  self.viewHeight.constant = 0; [UIView animateWithDuration:0.25 animations:^{ [self.view layoutIfNeeded]; }];  </description>
    </item>
    
    <item>
      <title>SFSafariViewController</title>
      <link>https://jepphu.github.io/2018/sfsafariviewcontroller/</link>
      <pubDate>Sun, 30 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/sfsafariviewcontroller/</guid>
      <description>不用跳出 app，直接在 app 内打开隐私协议等网址
#import &amp;lt;SafariServices/SafariServices.h&amp;gt;  &amp;lt;SFSafariViewControllerDelegate&amp;gt;  - (IBAction)action:(id)sender { NSURL *url = [NSURL URLWithString:@&amp;quot;https://jepphu.github.io/&amp;quot;]; SFSafariViewController *safariVC = [[SFSafariViewController alloc] initWithURL:url]; safariVC.delegate = self; // self.navigationController.navigationBarHidden = YES; // [self.navigationController pushViewController:safariVC animated:YES]; [self presentViewController:safariVC animated:YES completion:nil]; } // 加载完成 - (void)safariViewController:(SFSafariViewController *)controller didCompleteInitialLoad:(BOOL)didLoadSuccessfully { } // 按钮 Done - (void)safariViewControllerDidFinish:(SFSafariViewController *)controller { }  </description>
    </item>
    
    <item>
      <title>UIView 子视图坐标转换</title>
      <link>https://jepphu.github.io/2018/uiview%E5%AD%90%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 13 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiview%E5%AD%90%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</guid>
      <description>ViewA, ViewB, ViewC
ViewA 是 ViewB 的父视图，ViewB 是 ViewC 的父视图
ViewC 此时的 frame 是相对于 ViewB 的
如果需求为获取 ViewC 此时相对于 ViewA 的 frame
- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view; - (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view; CGRect frame = [ViewB convertRect:ViewC.frame toView:ViewA]; //或 CGRect frame = [ViewA convertRect:ViewC.frame fromView:ViewB];  </description>
    </item>
    
    <item>
      <title>UINavigationBar</title>
      <link>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</link>
      <pubDate>Mon, 09 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uinavgationbar%E5%BA%95%E9%83%A8%E7%9A%84%E7%BA%BF/</guid>
      <description>UINavgationBar 设置颜色 UINavigationController *nav = self.navigationController; nav.navigationBar.tintColor = [UIColor whiteColor]; nav.navigationBar.barTintColor = [UIColor colorWithRed:28/255.0 green:152/255.0 blue:225/255.0 alpha:1.0]; nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor whiteColor]};  此时会觉得 navigationbar 颜色很浅，因为这是半透明状态
默认 navigationbar.translucent = YES
改为 navigationbar.translucent = NO
颜色问题解决，但是子控制器视图整体下移，加上下面这句
self.extendedLayoutIncludesOpaqueBars = YES;
或者在 storyboard 中 viewController 属性勾选 Under Opaque Bars
如果有特殊需求，尝试使用下面的方法
透明化和显示 UINavigationBar 以及 UINavigationBar 底部的线  方法1：  - (UIImageView *)navigationBarLineUnder:(UIView *)navigationBar { if ([navigationBar isKindOfClass:[UIImageView class]] &amp;amp;&amp;amp; navigationBar.bounds.size.height &amp;lt;= 1.0) { return (UIImageView *)navigationBar; } for (UIView *subview in navigationBar.</description>
    </item>
    
    <item>
      <title>present 一个 navigation</title>
      <link>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</link>
      <pubDate>Mon, 09 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/present%E4%B8%80%E4%B8%AAnavigation/</guid>
      <description>在 present 页面之后的页面需要使用 navigation
UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:logInVC]; nav.navigationBar.tintColor = [UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0]; nav.navigationBar.barTintColor = [UIColor whiteColor]; nav.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName :[UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0]}; [self presentViewController:nav animated:NO completion:nil];  为 present 出来的 navigation 添加返回按钮
if (self.navigationController.navigationItem.hidesBackButton) { self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&amp;quot;Back&amp;quot; style:UIBarButtonItemStylePlain target:self action:@selector(dismissVC)]; } - (void)dismissVC { [self dismissViewControllerAnimated:YES completion:nil]; }  </description>
    </item>
    
    <item>
      <title>App 发送邮件</title>
      <link>https://jepphu.github.io/2018/app%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</link>
      <pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/app%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</guid>
      <description>iOS App 发送邮件 #import &amp;lt;MessageUI/MessageUI.h&amp;gt;  &amp;lt;MFMailComposeViewControllerDelegate&amp;gt;  [self sendEmail:@&amp;quot;jepp.hu@mail.com&amp;quot;];  - (void)sendEmail:(NSString *)email { if ([MFMailComposeViewController canSendMail]) { // [self.navigationController presentViewController:[self configuredMailComposeViewControllerWithEmail:email] animated:YES completion:nil]; [self presentViewController:[self configuredMailComposeViewControllerWithEmail:email] animated:YES completion:nil]; } else { UIAlertController *sendMailErrorAlert = [UIAlertController alertControllerWithTitle:@&amp;quot;Can not send&amp;quot; message:@&amp;quot;Please set your email&amp;quot; preferredStyle:UIAlertControllerStyleAlert]; [sendMailErrorAlert addAction:[UIAlertAction actionWithTitle:@&amp;quot;OK&amp;quot; style:UIAlertActionStyleDefault handler:nil]]; // [self.navigationController presentViewController:sendMailErrorAlert animated:YES completion:nil]; [self presentViewController:sendMailErrorAlert animated:YES completion:nil]; } } - (MFMailComposeViewController *)configuredMailComposeViewControllerWithEmail:(NSString *)email { MFMailComposeViewController *mfVC = [[MFMailComposeViewController alloc] init]; mfVC.</description>
    </item>
    
    <item>
      <title>UIView 事件拦截</title>
      <link>https://jepphu.github.io/2018/uiview%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/</link>
      <pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/uiview%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/</guid>
      <description>hitTest: 方法会递归来寻找第一响应者  判断 point 是否在自身范围内，不在则返回 nil，在则执行第 2 步 检查 subViews，判断 point 是否在 subView 范围内，在则返回 subView（此时 subView 成为第一响应者，subView会执行 hitTest:） 如果所有 subViews 都不包含 point，只有自身包含（第1步）那就返回 self（自身成为第一响应者）  subViews 上的事件全部由父 View 来实现 重写父级 View 的 hitTest 方法，返回 self，自身成为第一响应者
subViews 的 touch 相关方法不会响应
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{ // 直接返回 self 这样自身就成为了第一响应者 subViews 不能够接受到响应事件 if (CGRectContainsPoint(self.bounds, point)) { return self; } return nil; }  允许部分 subViews 响应事件 重写父级 View 的 hitTest 方法，返回某个 subView，subView 成为第一响应者</description>
    </item>
    
    <item>
      <title>绘制 image</title>
      <link>https://jepphu.github.io/2018/%E7%BB%98%E5%88%B6image/</link>
      <pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2018/%E7%BB%98%E5%88%B6image/</guid>
      <description> 绘制空白的 image UIColor *color = [UIColor whiteColor]; CGRect rect = CGRectMake(0, 0, 200, 200); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, color.CGColor); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();  </description>
    </item>
    
    <item>
      <title>viewController 生命周期</title>
      <link>https://jepphu.github.io/2016/viewcontroller%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Wed, 28 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jepphu.github.io/2016/viewcontroller%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>viewController 生命周期  viewController 的创建 （xib，storyBoard）
- (instancetype)initWithCoder:(NSCoder *)aDecoder;
 view 的创建
- (void)loadView;
 view 是懒加载的 只有系统认为需要生成一个 view 的时候，才会调用这个方法来创建一个 view，这个时候通常是 presentViewController: 或 pushViewController: 的时候 当只有 viewController 的初始化的时候，不会创建一个 view， 也不会走 - (void)viewDidLoad 想要不 presentViewController: 或 pushViewController: 的情况下创建 view，访问一下 view 即可，[ViewController view] 一但重写了 loadView，需要自己创建 view，这个时候可以生成一个 UIImageView , WKWebView 等其它 view    - (void)loadView { UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&amp;quot;Default&amp;quot;]]; imageView.frame = [UIScreen mainScreen].bounds; imageView.userInteractionEnabled = YES; self.</description>
    </item>
    
  </channel>
</rss>